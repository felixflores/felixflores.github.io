<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Buddhabrot Background</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100vh;
        }

        #buddhabrot-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            cursor: grab;
        }

        #buddhabrot-canvas:active {
            cursor: grabbing;
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            color: white;
            font-family: monospace;
            font-size: 12px;
            z-index: 100;
            min-width: 220px;
        }

        .controls h3 {
            margin: 0 0 15px 0;
            font-size: 14px;
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group label {
            display: block;
            margin-bottom: 4px;
            color: #aaa;
        }

        .control-group input[type="range"] {
            width: 100%;
        }

        .control-group select {
            width: 100%;
            padding: 4px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
        }

        .control-group .value {
            float: right;
            color: #f90;
        }

        button {
            width: 100%;
            padding: 8px;
            margin-top: 10px;
            background: #f90;
            color: black;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        button:hover {
            background: #fa0;
        }

        #status {
            margin-top: 10px;
            color: #888;
            font-size: 11px;
        }

        .zoom-hint {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: rgba(0,0,0,0.6);
            padding: 10px 15px;
            border-radius: 6px;
            color: #888;
            font-family: monospace;
            font-size: 11px;
            z-index: 100;
        }

        .minimap-container {
            position: fixed;
            bottom: 80px;
            right: 30px;
            background: rgba(0,0,0,0.8);
            padding: 8px;
            border-radius: 8px;
            z-index: 100;
        }

        .minimap-container canvas {
            display: block;
            border-radius: 4px;
        }

        .minimap-label {
            color: #666;
            font-family: monospace;
            font-size: 10px;
            margin-top: 5px;
            text-align: center;
        }

        .info {
            position: fixed;
            bottom: 30px;
            left: 30px;
            max-width: 400px;
            background: rgba(0,0,0,0.75);
            padding: 20px 25px;
            border-radius: 10px;
            color: #ccc;
            font-family: Georgia, serif;
            font-size: 15px;
            line-height: 1.6;
            z-index: 100;
        }

        .info h2 {
            margin: 0 0 12px 0;
            color: #fff;
            font-size: 18px;
            font-weight: normal;
        }

        .info p {
            margin: 0;
        }

        .equation {
            text-align: center;
            margin: 18px 0 14px 0;
            font-family: 'Times New Roman', Times, serif;
            font-size: 26px;
            font-style: italic;
            color: #fff;
            letter-spacing: 2px;
        }

        .equation sup {
            font-size: 16px;
            vertical-align: super;
        }

        .equation sub {
            font-size: 14px;
            vertical-align: sub;
            color: #999;
        }

        /* How It Works Modal */
        .how-it-works-btn {
            position: fixed;
            bottom: 30px;
            left: 30px;
            background: rgba(100, 140, 200, 0.9);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-family: Georgia, serif;
            font-size: 14px;
            cursor: pointer;
            z-index: 101;
            transition: background 0.2s;
        }

        .how-it-works-btn:hover {
            background: rgba(120, 160, 220, 1);
        }

        .info.hidden {
            display: none;
        }

        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 200;
            overflow-y: auto;
        }

        .modal-overlay.visible {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 40px 20px;
        }

        .modal-content {
            background: #1a1a1a;
            border-radius: 16px;
            max-width: 900px;
            width: 100%;
            padding: 40px;
            color: #ddd;
            font-family: Georgia, serif;
            line-height: 1.7;
        }

        .modal-content h1 {
            margin: 0 0 10px 0;
            color: #fff;
            font-size: 28px;
            font-weight: normal;
        }

        .modal-content h2 {
            margin: 30px 0 15px 0;
            color: #fff;
            font-size: 20px;
            font-weight: normal;
            border-bottom: 1px solid #333;
            padding-bottom: 8px;
        }

        .modal-content p {
            margin: 0 0 15px 0;
        }

        .modal-close {
            position: absolute;
            top: 20px;
            right: 30px;
            background: none;
            border: none;
            color: #888;
            font-size: 32px;
            cursor: pointer;
            padding: 0;
            width: auto;
        }

        .modal-close:hover {
            color: #fff;
            background: none;
        }

        .demo-container {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .demo-panel {
            flex: 1;
            min-width: 280px;
            background: #111;
            border-radius: 10px;
            padding: 15px;
        }

        .demo-panel h3 {
            margin: 0 0 10px 0;
            color: #aaa;
            font-size: 13px;
            font-family: monospace;
            font-weight: normal;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .demo-panel canvas {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 6px;
            cursor: crosshair;
        }

        .demo-controls {
            margin-top: 12px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .demo-controls button {
            flex: 1;
            min-width: 80px;
            padding: 8px 12px;
            font-size: 12px;
            margin: 0;
        }

        .demo-info {
            margin-top: 12px;
            font-family: monospace;
            font-size: 11px;
            color: #888;
            min-height: 40px;
        }

        .demo-info .escaping {
            color: #4a9;
        }

        .demo-info .bounded {
            color: #c44;
        }

        .step-list {
            background: #111;
            border-radius: 10px;
            padding: 20px 25px;
            margin: 20px 0;
        }

        .step-list ol {
            margin: 0;
            padding-left: 20px;
        }

        .step-list li {
            margin-bottom: 12px;
            color: #ccc;
        }

        .step-list li strong {
            color: #f90;
        }

        .color-legend {
            display: flex;
            gap: 20px;
            margin: 15px 0;
            font-family: monospace;
            font-size: 13px;
        }

        .color-legend span {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .color-dot.red { background: #f44; }
        .color-dot.green { background: #4f4; }
        .color-dot.blue { background: #44f; }
    </style>
</head>
<body>
    <canvas id="buddhabrot-canvas"></canvas>

    <button class="how-it-works-btn" id="openHowItWorks">How It Works</button>

    <div class="modal-overlay" id="howItWorksModal">
        <div class="modal-content">
            <button class="modal-close" id="closeModal">&times;</button>

            <h1>The Buddhabrot</h1>
            <p>This ghostly figure emerges from a simple equation repeated millions of times. No one designed it—it was discovered hiding in pure mathematics.</p>

            <h2>The Algorithm</h2>
            <div class="step-list">
                <ol>
                    <li><strong>Pick a random point c</strong> in the complex plane (the starting position)</li>
                    <li><strong>Iterate the equation:</strong> z<sub>n+1</sub> = z<sub>n</sub><sup>2</sup> + c, starting with z<sub>0</sub> = 0</li>
                    <li><strong>Track the orbit</strong>—the sequence of points z visits</li>
                    <li><strong>If the orbit escapes</strong> (|z| > 2), record every point it visited</li>
                    <li><strong>If the orbit stays bounded</strong>, discard it (these points are in the Mandelbrot set)</li>
                    <li><strong>Repeat millions of times</strong> and count how often each pixel was visited</li>
                </ol>
            </div>

            <h2>Interactive Demo</h2>
            <p>Click anywhere on the left panel to pick a starting point c. Watch how the orbit (the path) evolves. Only escaping orbits contribute to the final image.</p>

            <div class="demo-container">
                <div class="demo-panel">
                    <h3>Complex Plane (pick point c)</h3>
                    <canvas id="demo-plane" width="400" height="400"></canvas>
                    <div class="demo-controls">
                        <button id="demo-random">Random Point</button>
                        <button id="demo-animate" style="background:#68c;">Animate</button>
                        <button id="demo-clear" style="background:#666;">Clear</button>
                    </div>
                    <div class="demo-info" id="demo-info">Click to select a starting point c</div>
                </div>
                <div class="demo-panel">
                    <h3>Accumulated Hits</h3>
                    <canvas id="demo-accum" width="400" height="400"></canvas>
                    <div class="demo-controls">
                        <button id="demo-run100" style="background:#4a9;">Run 100 Orbits</button>
                        <button id="demo-reset" style="background:#666;">Reset</button>
                    </div>
                    <div class="demo-info" id="accum-info">Escaping orbits: 0 | Total hits: 0</div>
                </div>
            </div>

            <h2>The Colors (Nebulabrot)</h2>
            <p>The Nebulabrot variation uses different iteration limits for each color channel, revealing structure at multiple scales:</p>
            <div class="color-legend">
                <span><div class="color-dot red"></div> Red: 20,000 iterations (long journeys)</span>
                <span><div class="color-dot green"></div> Green: 2,000 iterations</span>
                <span><div class="color-dot blue"></div> Blue: 200 iterations (short journeys)</span>
            </div>
            <p>Short orbits tend to stay near the Mandelbrot set boundary, while long orbits wander further—creating the ethereal, nebula-like appearance.</p>

            <h2>Why "Buddhabrot"?</h2>
            <p>The name was coined by Lori Gardi in 1993 when she noticed the figure's resemblance to a seated Buddha in meditation. The shape emerges naturally from the mathematics—a surprising example of order arising from chaos.</p>
        </div>
    </div>

    <div class="controls">
        <h3>Nebulabrot</h3>

        <div class="control-group">
            <label>Quality</label>
            <select id="quality">
                <option value="preview">Preview (fast)</option>
                <option value="medium" selected>Medium</option>
                <option value="high">High (slow)</option>
            </select>
        </div>

        <div class="control-group">
            <label>Workers <span class="value" id="workersVal"></span></label>
            <input type="range" id="numWorkersSlider" min="1" max="32" step="1" value="8">
        </div>

        <div class="control-group">
            <label>Noise Floor <span class="value" id="floorVal">0</span></label>
            <input type="range" id="noiseFloor" min="0" max="50" step="1" value="0">
        </div>

        <div class="control-group">
            <label>Exposure <span class="value" id="exposureVal">0</span></label>
            <input type="range" id="exposure" min="-3" max="3" step="0.1" value="0">
        </div>

        <div class="control-group">
            <label>Contrast <span class="value" id="contrastVal">1.0</span></label>
            <input type="range" id="contrast" min="0.5" max="2.0" step="0.1" value="1.0">
        </div>

        <div class="control-group">
            <label>Highlight Compression <span class="value" id="compressVal">0.5</span></label>
            <input type="range" id="compress" min="0.1" max="1.0" step="0.05" value="0.5">
        </div>

        <button id="regenerate">Regenerate</button>
        <button id="resetView" style="background:#666; margin-top:5px;">Reset View</button>
        <button id="download" style="background:#4a9; margin-top:5px;">Download PNG</button>
        <button id="copyLink" style="background:#68c; margin-top:5px;">Copy Link</button>
        <div id="status">Ready</div>
        <div id="zoomLevel" style="margin-top:8px; color:#666;">Zoom: 1.0x</div>
    </div>

    <div class="minimap-container">
        <canvas id="minimap" width="150" height="150"></canvas>
        <div class="minimap-label">Overview</div>
    </div>

    <div class="zoom-hint">
        Scroll to zoom · Drag to pan
    </div>

    <script>
        const canvas = document.getElementById('buddhabrot-canvas');
        let ctx = canvas.getContext('2d');

        // Minimap
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        const MINIMAP_SIZE = 150;
        let minimapImgR = null, minimapImgG = null, minimapImgB = null;
        let minimapReady = false;
        let minimapSamples = 0;

        // Full view bounds for minimap (what zoom=1 shows)
        const FULL_RE_MIN = -2.0, FULL_RE_MAX = 1.0;
        const FULL_IM_MIN = -1.5, FULL_IM_MAX = 1.5;

        // Three channels for Nebulabrot (R=high iter, G=mid iter, B=low iter)
        let imgR = null, imgG = null, imgB = null;
        let width, height;

        // Preview canvas for smooth panning
        const previewCanvas = document.createElement('canvas');
        const previewCtx = previewCanvas.getContext('2d');
        let lastViewState = null;

        // Parallel workers
        const detectedCores = navigator.hardwareConcurrency || 8;
        let numWorkers = detectedCores;
        let workers = [];

        // Initialize workers slider with detected cores
        const numWorkersSlider = document.getElementById('numWorkersSlider');
        numWorkersSlider.value = detectedCores;
        numWorkersSlider.max = Math.max(32, detectedCores * 2);
        document.getElementById('workersVal').textContent = detectedCores;

        numWorkersSlider.oninput = () => {
            numWorkers = parseInt(numWorkersSlider.value);
            document.getElementById('workersVal').textContent = numWorkers;
        };
        numWorkersSlider.onchange = () => {
            startRender();
        };

        // Worker code
        const workerCode = `
            const ITER_R = 20000;
            const ITER_G = 2000;
            const ITER_B = 200;
            const UPDATE_INTERVAL = 2000;

            // Importance sampling grid
            const GRID_SIZE = 32;
            const WARMUP_SAMPLES = 20000;
            const IMPORTANCE_BLEND = 0.7; // How much to favor high-density regions

            let width, height;
            let viewReMin, viewReMax, viewImMin, viewImMax;
            let imgR, imgG, imgB;
            let localSamples = 0;
            let running = false;

            // Zoom-adaptive sampling parameters
            let adaptivePadding, viewSamplePct, annularThreshold;
            let sampleReMin, sampleReMax, sampleImMin, sampleImMax;

            // Density tracking for importance sampling
            let densityGrid = null;
            let densityCDF = null;
            let gridCellWidth, gridCellHeight;

            function calculateSamplingParams() {
                const viewHeight = viewReMax - viewReMin;
                const viewWidth = viewImMax - viewImMin;
                const viewSize = Math.max(viewHeight, viewWidth);

                adaptivePadding = Math.max(0.05, viewSize * 0.5);

                const zoomLevel = 3.0 / viewSize;
                viewSamplePct = Math.min(0.98, 0.25 + 0.73 * (1 - 1 / Math.max(1, zoomLevel)));

                const remaining = 1 - viewSamplePct;
                annularThreshold = viewSamplePct + remaining * 0.8;

                sampleReMin = Math.max(-2.5, viewReMin - adaptivePadding);
                sampleReMax = Math.min(1.5, viewReMax + adaptivePadding);
                sampleImMin = Math.max(-2.0, viewImMin - adaptivePadding);
                sampleImMax = Math.min(2.0, viewImMax + adaptivePadding);

                // Initialize density grid for c-space
                densityGrid = new Float32Array(GRID_SIZE * GRID_SIZE);
                densityCDF = new Float32Array(GRID_SIZE * GRID_SIZE);
                gridCellWidth = (sampleImMax - sampleImMin) / GRID_SIZE;
                gridCellHeight = (sampleReMax - sampleReMin) / GRID_SIZE;
            }

            function getGridIndex(cRe, cIm) {
                const gx = Math.floor((cIm - sampleImMin) / gridCellWidth);
                const gy = Math.floor((cRe - sampleReMin) / gridCellHeight);
                if (gx < 0 || gx >= GRID_SIZE || gy < 0 || gy >= GRID_SIZE) return -1;
                return gy * GRID_SIZE + gx;
            }

            function buildCDF() {
                // Add small base probability to all cells to ensure exploration
                const baseProb = 0.1 / (GRID_SIZE * GRID_SIZE);
                let total = 0;

                for (let i = 0; i < densityGrid.length; i++) {
                    // Use sqrt to reduce variance between high/low density regions
                    total += Math.sqrt(densityGrid[i] + 1) + baseProb;
                }

                let cumulative = 0;
                for (let i = 0; i < densityGrid.length; i++) {
                    cumulative += (Math.sqrt(densityGrid[i] + 1) + baseProb) / total;
                    densityCDF[i] = cumulative;
                }
                densityCDF[densityCDF.length - 1] = 1.0; // Ensure last is exactly 1
            }

            function sampleFromCDF() {
                const r = Math.random();
                // Binary search for cell
                let lo = 0, hi = densityCDF.length - 1;
                while (lo < hi) {
                    const mid = (lo + hi) >> 1;
                    if (densityCDF[mid] < r) lo = mid + 1;
                    else hi = mid;
                }
                return lo;
            }

            function sampleFromGrid() {
                const cellIdx = sampleFromCDF();
                const gx = cellIdx % GRID_SIZE;
                const gy = Math.floor(cellIdx / GRID_SIZE);

                // Random point within the cell
                const cIm = sampleImMin + (gx + Math.random()) * gridCellWidth;
                const cRe = sampleReMin + (gy + Math.random()) * gridCellHeight;
                return { cRe, cIm };
            }

            function traceOrbitWithDensity(cRe, cIm, maxIter, hits) {
                let zRe = 0, zIm = 0;
                const orbitRe = new Float64Array(maxIter);
                const orbitIm = new Float64Array(maxIter);
                let orbitLen = 0;

                for (let i = 0; i < maxIter; i++) {
                    orbitRe[orbitLen] = zRe;
                    orbitIm[orbitLen] = zIm;
                    orbitLen++;

                    const zRe2 = zRe * zRe - zIm * zIm + cRe;
                    const zIm2 = 2 * zRe * zIm + cIm;
                    zRe = zRe2;
                    zIm = zIm2;

                    if (zRe * zRe + zIm * zIm > 4) break;
                }

                let hitCount = 0;
                if (orbitLen < maxIter) {
                    for (let i = 0; i < orbitLen; i++) {
                        const pRe = orbitRe[i];
                        const pIm = orbitIm[i];

                        if (pRe >= viewReMin && pRe <= viewReMax && pIm >= viewImMin && pIm <= viewImMax) {
                            const x = Math.floor((pIm - viewImMin) / (viewImMax - viewImMin) * (width - 1));
                            const y = Math.floor((pRe - viewReMin) / (viewReMax - viewReMin) * (height - 1));

                            if (x >= 0 && x < width && y >= 0 && y < height) {
                                hits[y * width + x]++;
                                hitCount++;
                            }
                        }
                    }
                }
                return hitCount;
            }

            function runSampling() {
                if (!running) return;

                const useImportance = localSamples >= WARMUP_SAMPLES;

                // Rebuild CDF periodically after warmup
                if (useImportance && localSamples % 10000 === 0) {
                    buildCDF();
                }

                for (let s = 0; s < UPDATE_INTERVAL; s++) {
                    let cRe, cIm;

                    // First decide: importance sampling or regular?
                    const useImportanceThisSample = useImportance && Math.random() < IMPORTANCE_BLEND;

                    if (useImportanceThisSample) {
                        // Importance sampling from density grid
                        const sample = sampleFromGrid();
                        cRe = sample.cRe;
                        cIm = sample.cIm;
                    } else {
                        // Regular sampling with zoom-adaptive distribution
                        const r = Math.random();
                        if (r < viewSamplePct) {
                            // View-adaptive uniform sampling
                            cRe = Math.random() * (sampleReMax - sampleReMin) + sampleReMin;
                            cIm = Math.random() * (sampleImMax - sampleImMin) + sampleImMin;
                        } else if (r < annularThreshold) {
                            const theta = Math.random() * Math.PI * 2;
                            const radius = 0.3 + Math.random() * 0.9;
                            cRe = radius * Math.cos(theta) - 0.5;
                            cIm = radius * Math.sin(theta);
                        } else {
                            cRe = -2 + Math.random() * 0.5;
                            cIm = (Math.random() - 0.5) * 0.2;
                        }
                    }

                    // Skip points in main cardioid or period-2 bulb
                    const q = (cRe - 0.25) * (cRe - 0.25) + cIm * cIm;
                    if (q * (q + (cRe - 0.25)) < 0.25 * cIm * cIm) continue;
                    if ((cRe + 1) * (cRe + 1) + cIm * cIm < 0.0625) continue;

                    // Trace and track density
                    const hitsB = traceOrbitWithDensity(cRe, cIm, ITER_B, imgB);
                    const hitsG = traceOrbitWithDensity(cRe, cIm, ITER_G, imgG);
                    const hitsR = traceOrbitWithDensity(cRe, cIm, ITER_R, imgR);

                    // Update density grid (weight by total hits across all channels)
                    const totalHits = hitsB + hitsG + hitsR;
                    if (totalHits > 0) {
                        const gridIdx = getGridIndex(cRe, cIm);
                        if (gridIdx >= 0) {
                            densityGrid[gridIdx] += totalHits;
                        }
                    }
                }
                localSamples += UPDATE_INTERVAL;

                // Build initial CDF right after warmup
                if (localSamples === WARMUP_SAMPLES + UPDATE_INTERVAL) {
                    buildCDF();
                }

                self.postMessage({
                    type: 'update',
                    samples: UPDATE_INTERVAL,
                    imgR: imgR,
                    imgG: imgG,
                    imgB: imgB
                });

                imgR = new Float32Array(width * height);
                imgG = new Float32Array(width * height);
                imgB = new Float32Array(width * height);

                setTimeout(runSampling, 0);
            }

            self.onmessage = function(e) {
                const { type, data } = e.data;

                if (type === 'init') {
                    width = data.width;
                    height = data.height;
                    viewReMin = data.viewReMin;
                    viewReMax = data.viewReMax;
                    viewImMin = data.viewImMin;
                    viewImMax = data.viewImMax;
                    calculateSamplingParams();
                    imgR = new Float32Array(width * height);
                    imgG = new Float32Array(width * height);
                    imgB = new Float32Array(width * height);
                    localSamples = 0;
                    self.postMessage({ type: 'ready' });
                } else if (type === 'start') {
                    running = true;
                    runSampling();
                } else if (type === 'stop') {
                    running = false;
                }
            };
        `;

        const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(workerBlob);

        function initWorkers() {
            workers.forEach(w => w.terminate());
            workers = [];

            for (let i = 0; i < numWorkers; i++) {
                const worker = new Worker(workerUrl);
                worker.onmessage = handleWorkerMessage;
                workers.push(worker);
            }
        }

        let workersReady = 0;
        function handleWorkerMessage(e) {
            const { type, samples, imgR: wR, imgG: wG, imgB: wB } = e.data;

            if (type === 'ready') {
                workersReady++;
                if (workersReady === numWorkers) {
                    workers.forEach(w => w.postMessage({ type: 'start' }));
                }
            } else if (type === 'update') {
                for (let i = 0; i < imgR.length; i++) {
                    imgR[i] += wR[i];
                    imgG[i] += wG[i];
                    imgB[i] += wB[i];
                }
                totalSamples += samples;
            }
        }

        function stopWorkers() {
            workers.forEach(w => {
                w.postMessage({ type: 'stop' });
                w.terminate();
            });
            workers = [];
        }

        // View bounds
        let viewReMin, viewReMax, viewImMin, viewImMax;

        // View state
        let viewCenterRe = -0.5;
        let viewCenterIm = 0;
        let zoom = 1.0;

        let animationId = null;
        let totalSamples = 0;

        // Controls
        const qualitySelect = document.getElementById('quality');
        const noiseFloorSlider = document.getElementById('noiseFloor');
        const exposureSlider = document.getElementById('exposure');
        const contrastSlider = document.getElementById('contrast');
        const compressSlider = document.getElementById('compress');
        const regenerateBtn = document.getElementById('regenerate');
        const resetViewBtn = document.getElementById('resetView');
        const statusEl = document.getElementById('status');
        const zoomLevelEl = document.getElementById('zoomLevel');

        noiseFloorSlider.oninput = () => {
            document.getElementById('floorVal').textContent = noiseFloorSlider.value;
            render();
            saveToStorage();
        };
        exposureSlider.oninput = () => {
            document.getElementById('exposureVal').textContent = exposureSlider.value;
            render();
            saveToStorage();
        };
        contrastSlider.oninput = () => {
            document.getElementById('contrastVal').textContent = contrastSlider.value;
            render();
            saveToStorage();
        };
        compressSlider.oninput = () => {
            document.getElementById('compressVal').textContent = compressSlider.value;
            render();
            saveToStorage();
        };
        qualitySelect.onchange = () => saveToStorage();
        regenerateBtn.onclick = () => startRender();
        resetViewBtn.onclick = () => {
            viewCenterRe = -0.5;
            viewCenterIm = 0;
            zoom = 1.0;
            startRender();
        };

        document.getElementById('download').onclick = () => {
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = canvas.width;
            exportCanvas.height = canvas.height;
            const exportCtx = exportCanvas.getContext('2d');

            exportCtx.drawImage(canvas, 0, 0);

            const padding = 20;
            const minimapX = canvas.width - MINIMAP_SIZE - padding;
            const minimapY = canvas.height - MINIMAP_SIZE - padding;

            exportCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            exportCtx.roundRect(minimapX - 8, minimapY - 8, MINIMAP_SIZE + 16, MINIMAP_SIZE + 16, 8);
            exportCtx.fill();

            exportCtx.drawImage(minimapCanvas, minimapX, minimapY);

            exportCtx.fillStyle = '#666';
            exportCtx.font = '10px monospace';
            exportCtx.textAlign = 'center';
            exportCtx.fillText('Overview', minimapX + MINIMAP_SIZE / 2, minimapY + MINIMAP_SIZE + 14);

            const link = document.createElement('a');
            link.download = `nebulabrot-${zoom.toFixed(1)}x-${Date.now()}.png`;
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
        };

        document.getElementById('copyLink').onclick = () => {
            const params = new URLSearchParams({
                re: viewCenterRe.toFixed(10),
                im: viewCenterIm.toFixed(10),
                z: zoom.toFixed(4),
                floor: noiseFloorSlider.value,
                exp: exposureSlider.value,
                con: contrastSlider.value,
                comp: compressSlider.value,
                q: qualitySelect.value
            });
            const url = `${window.location.origin}${window.location.pathname}?${params}`;
            navigator.clipboard.writeText(url).then(() => {
                const btn = document.getElementById('copyLink');
                btn.textContent = 'Copied!';
                btn.style.background = '#4a9';
                setTimeout(() => {
                    btn.textContent = 'Copy Link';
                    btn.style.background = '#68c';
                }, 2000);
            });
        };

        function loadFromURL() {
            const params = new URLSearchParams(window.location.search);
            if (params.has('re')) viewCenterRe = parseFloat(params.get('re'));
            if (params.has('im')) viewCenterIm = parseFloat(params.get('im'));
            if (params.has('z')) zoom = parseFloat(params.get('z'));
            if (params.has('floor')) {
                noiseFloorSlider.value = params.get('floor');
                document.getElementById('floorVal').textContent = params.get('floor');
            }
            if (params.has('exp')) {
                exposureSlider.value = params.get('exp');
                document.getElementById('exposureVal').textContent = params.get('exp');
            }
            if (params.has('con')) {
                contrastSlider.value = params.get('con');
                document.getElementById('contrastVal').textContent = params.get('con');
            }
            if (params.has('comp')) {
                compressSlider.value = params.get('comp');
                document.getElementById('compressVal').textContent = params.get('comp');
            }
            if (params.has('q')) qualitySelect.value = params.get('q');
        }

        function loadFromStorage() {
            const saved = localStorage.getItem('buddhabrot-view');
            if (saved) {
                try {
                    const state = JSON.parse(saved);
                    viewCenterRe = state.re ?? viewCenterRe;
                    viewCenterIm = state.im ?? viewCenterIm;
                    zoom = state.z ?? zoom;
                    if (state.floor !== undefined) {
                        noiseFloorSlider.value = state.floor;
                        document.getElementById('floorVal').textContent = state.floor;
                    }
                    if (state.exp !== undefined) {
                        exposureSlider.value = state.exp;
                        document.getElementById('exposureVal').textContent = state.exp;
                    }
                    if (state.con !== undefined) {
                        contrastSlider.value = state.con;
                        document.getElementById('contrastVal').textContent = state.con;
                    }
                    if (state.comp !== undefined) {
                        compressSlider.value = state.comp;
                        document.getElementById('compressVal').textContent = state.comp;
                    }
                    if (state.q) qualitySelect.value = state.q;
                } catch (e) {}
            }
        }

        function saveToStorage() {
            const state = {
                re: viewCenterRe,
                im: viewCenterIm,
                z: zoom,
                floor: noiseFloorSlider.value,
                exp: exposureSlider.value,
                con: contrastSlider.value,
                comp: compressSlider.value,
                q: qualitySelect.value
            };
            localStorage.setItem('buddhabrot-view', JSON.stringify(state));

            const params = new URLSearchParams({
                re: viewCenterRe.toFixed(10),
                im: viewCenterIm.toFixed(10),
                z: zoom.toFixed(4),
                floor: noiseFloorSlider.value,
                exp: exposureSlider.value,
                con: contrastSlider.value,
                comp: compressSlider.value,
                q: qualitySelect.value
            });
            history.replaceState(null, '', `?${params}`);
        }

        loadFromStorage();
        loadFromURL();

        function updateViewBounds() {
            const baseHeight = 3.0;
            const screenAspect = width / height;

            let viewHeight = baseHeight / zoom;
            let viewWidth = viewHeight * screenAspect;

            viewReMin = viewCenterRe - viewHeight / 2;
            viewReMax = viewCenterRe + viewHeight / 2;
            viewImMin = viewCenterIm - viewWidth / 2;
            viewImMax = viewCenterIm + viewWidth / 2;

            zoomLevelEl.textContent = `Zoom: ${zoom.toFixed(1)}x`;

            if (minimapReady) {
                renderMinimap();
            }
        }

        function startRender() {
            if (animationId) cancelAnimationFrame(animationId);
            stopWorkers();

            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight;

            if (width && height && imgR && totalSamples > 0) {
                lastViewState = {
                    viewReMin, viewReMax, viewImMin, viewImMax,
                    width, height
                };
                previewCanvas.width = width;
                previewCanvas.height = height;
                previewCtx.drawImage(canvas, 0, 0);
            }

            canvas.width = newWidth;
            canvas.height = newHeight;
            width = newWidth;
            height = newHeight;

            updateViewBounds();
            saveToStorage();

            if (lastViewState) {
                drawTransformedPreview();
            }

            imgR = new Float32Array(width * height);
            imgG = new Float32Array(width * height);
            imgB = new Float32Array(width * height);
            totalSamples = 0;
            workersReady = 0;

            initWorkers();
            for (const worker of workers) {
                worker.postMessage({
                    type: 'init',
                    data: { width, height, viewReMin, viewReMax, viewImMin, viewImMax }
                });
            }
            renderLoop();
        }

        function renderLoop() {
            const quality = qualitySelect.value;
            // Fixed targets - adaptive sampling provides consistent performance at any zoom
            const targets = {
                preview: 500000,
                medium: 3000000,
                high: 15000000
            };
            const targetSamples = targets[quality];

            function frame() {
                render();
                const pct = Math.round(totalSamples / targetSamples * 100);
                statusEl.textContent = `${Math.min(100, pct)}% (${(totalSamples/1000000).toFixed(1)}M) [${numWorkers} workers]`;

                if (totalSamples < targetSamples) {
                    animationId = requestAnimationFrame(frame);
                } else {
                    stopWorkers();
                    statusEl.textContent = `Done: ${(totalSamples/1000000).toFixed(1)}M samples`;
                }
            }
            frame();
        }

        function drawTransformedPreview() {
            if (!lastViewState) return;

            const old = lastViewState;
            const oldImRange = old.viewImMax - old.viewImMin;
            const oldReRange = old.viewReMax - old.viewReMin;
            const newImRange = viewImMax - viewImMin;
            const newReRange = viewReMax - viewReMin;

            const scaleX = (oldImRange / newImRange) * (width / old.width);
            const scaleY = (oldReRange / newReRange) * (height / old.height);

            const offsetX = ((old.viewImMin - viewImMin) / newImRange) * width;
            const offsetY = ((old.viewReMin - viewReMin) / newReRange) * height;

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            ctx.globalAlpha = 0.6;
            ctx.drawImage(previewCanvas, offsetX, offsetY, old.width * scaleX, old.height * scaleY);
            ctx.globalAlpha = 1.0;
        }

        window.addEventListener('resize', startRender);

        function render() {
            const noiseFloor = parseInt(noiseFloorSlider.value);
            const exposure = parseFloat(exposureSlider.value);
            const contrast = parseFloat(contrastSlider.value);
            const compress = parseFloat(compressSlider.value);

            const imageData = ctx.createImageData(width, height);

            let maxR = 0, maxG = 0, maxB = 0;
            for (let i = 0; i < imgR.length; i++) {
                if (imgR[i] > noiseFloor && imgR[i] > maxR) maxR = imgR[i];
                if (imgG[i] > noiseFloor && imgG[i] > maxG) maxG = imgG[i];
                if (imgB[i] > noiseFloor && imgB[i] > maxB) maxB = imgB[i];
            }
            if (maxR === 0) maxR = 1;
            if (maxG === 0) maxG = 1;
            if (maxB === 0) maxB = 1;

            const expMult = Math.pow(2, exposure);

            function toneMap(val, max) {
                if (val <= noiseFloor) return 0;

                const normalized = Math.log(val - noiseFloor + 1) / Math.log(max - noiseFloor + 1);

                const midpoint = 0.5;
                let contrasted = midpoint + (normalized - midpoint) * contrast;
                contrasted = Math.max(0, Math.min(1, contrasted));

                let exposed = contrasted * expMult;

                const compressed = exposed / (exposed + compress);

                return Math.min(1, compressed / (1 / (1 + compress)));
            }

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const pixIdx = y * width + x;

                    const vR = toneMap(imgR[pixIdx], maxR);
                    const vG = toneMap(imgG[pixIdx], maxG);
                    const vB = toneMap(imgB[pixIdx], maxB);

                    imageData.data[idx] = Math.floor(vR * 255);
                    imageData.data[idx + 1] = Math.floor(vG * 255);
                    imageData.data[idx + 2] = Math.floor(vB * 255);
                    imageData.data[idx + 3] = 255;
                }
            }

            const quality = qualitySelect.value;
            const targets = {
                preview: 500000,
                medium: 3000000,
                high: 15000000
            };
            const targetSamples = targets[quality];
            const progress = Math.min(1, totalSamples / (targetSamples * 0.1));

            if (lastViewState && progress < 1) {
                drawTransformedPreview();
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.putImageData(imageData, 0, 0);
                ctx.globalAlpha = progress;
                ctx.drawImage(tempCanvas, 0, 0);
                ctx.globalAlpha = 1.0;
            } else {
                ctx.putImageData(imageData, 0, 0);
            }
        }

        // Pan and Zoom Controls
        let isDragging = false;
        let dragStartX, dragStartY;
        let dragStartCenterRe, dragStartCenterIm;

        canvas.addEventListener('mousedown', (e) => {
            if (e.target !== canvas) return;
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            dragStartCenterRe = viewCenterRe;
            dragStartCenterIm = viewCenterIm;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            const dx = e.clientX - dragStartX;
            const dy = e.clientY - dragStartY;

            const viewHeight = (viewReMax - viewReMin);
            const viewWidth = (viewImMax - viewImMin);

            viewCenterIm = dragStartCenterIm - (dx / width) * viewWidth;
            viewCenterRe = dragStartCenterRe - (dy / height) * viewHeight;

            updateViewBounds();
            startRender();
        });

        canvas.addEventListener('mouseup', () => { isDragging = false; });
        canvas.addEventListener('mouseleave', () => { isDragging = false; });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const mouseIm = viewImMin + (mouseX / width) * (viewImMax - viewImMin);
            const mouseRe = viewReMin + (mouseY / height) * (viewReMax - viewReMin);

            const zoomFactor = e.deltaY > 0 ? 0.8 : 1.25;
            const newZoom = Math.max(0.5, Math.min(1000, zoom * zoomFactor));

            if (newZoom !== zoom) {
                const zoomRatio = zoom / newZoom;
                viewCenterRe = mouseRe + (viewCenterRe - mouseRe) * zoomRatio;
                viewCenterIm = mouseIm + (viewCenterIm - mouseIm) * zoomRatio;
                zoom = newZoom;

                startRender();
            }
        }, { passive: false });

        // Touch support
        let lastTouchDist = 0;

        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isDragging = true;
                dragStartX = e.touches[0].clientX;
                dragStartY = e.touches[0].clientY;
                dragStartCenterRe = viewCenterRe;
                dragStartCenterIm = viewCenterIm;
            } else if (e.touches.length === 2) {
                isDragging = false;
                const dx = e.touches[1].clientX - e.touches[0].clientX;
                const dy = e.touches[1].clientY - e.touches[0].clientY;
                lastTouchDist = Math.sqrt(dx * dx + dy * dy);
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();

            if (e.touches.length === 1 && isDragging) {
                const dx = e.touches[0].clientX - dragStartX;
                const dy = e.touches[0].clientY - dragStartY;

                const viewHeight = (viewReMax - viewReMin);
                const viewWidth = (viewImMax - viewImMin);

                viewCenterIm = dragStartCenterIm - (dx / width) * viewWidth;
                viewCenterRe = dragStartCenterRe - (dy / height) * viewHeight;

                updateViewBounds();
                startRender();
            } else if (e.touches.length === 2 && lastTouchDist > 0) {
                const dx = e.touches[1].clientX - e.touches[0].clientX;
                const dy = e.touches[1].clientY - e.touches[0].clientY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                const zoomFactor = dist / lastTouchDist;
                const newZoom = Math.max(0.5, Math.min(1000, zoom * zoomFactor));

                if (newZoom !== zoom) {
                    zoom = newZoom;
                    lastTouchDist = dist;
                    startRender();
                }
            }
        }, { passive: false });

        canvas.addEventListener('touchend', () => {
            isDragging = false;
            lastTouchDist = 0;
        });

        // Minimap
        function initMinimap() {
            minimapImgR = new Float32Array(MINIMAP_SIZE * MINIMAP_SIZE);
            minimapImgG = new Float32Array(MINIMAP_SIZE * MINIMAP_SIZE);
            minimapImgB = new Float32Array(MINIMAP_SIZE * MINIMAP_SIZE);
            minimapSamples = 0;
            minimapReady = false;
            renderMinimapProgressive();
        }

        function traceOrbitMinimap(cRe, cIm, maxIter, imgArray) {
            let zRe = 0, zIm = 0;
            const orbitRe = new Float64Array(maxIter);
            const orbitIm = new Float64Array(maxIter);
            let orbitLen = 0;

            for (let i = 0; i < maxIter; i++) {
                orbitRe[orbitLen] = zRe;
                orbitIm[orbitLen] = zIm;
                orbitLen++;

                const zRe2 = zRe * zRe - zIm * zIm + cRe;
                const zIm2 = 2 * zRe * zIm + cIm;
                zRe = zRe2;
                zIm = zIm2;

                if (zRe * zRe + zIm * zIm > 4) break;
            }

            if (orbitLen < maxIter) {
                for (let i = 0; i < orbitLen; i++) {
                    const pRe = orbitRe[i];
                    const pIm = orbitIm[i];

                    if (pRe >= FULL_RE_MIN && pRe <= FULL_RE_MAX && pIm >= FULL_IM_MIN && pIm <= FULL_IM_MAX) {
                        const x = Math.floor((pIm - FULL_IM_MIN) / (FULL_IM_MAX - FULL_IM_MIN) * (MINIMAP_SIZE - 1));
                        const y = Math.floor((pRe - FULL_RE_MIN) / (FULL_RE_MAX - FULL_RE_MIN) * (MINIMAP_SIZE - 1));

                        if (x >= 0 && x < MINIMAP_SIZE && y >= 0 && y < MINIMAP_SIZE) {
                            imgArray[y * MINIMAP_SIZE + x]++;
                        }
                    }
                }
            }
        }

        function generateMinimapSamples(count) {
            for (let s = 0; s < count; s++) {
                let cRe, cIm;
                const r = Math.random();
                if (r < 0.6) {
                    const theta = Math.random() * Math.PI * 2;
                    const radius = 0.3 + Math.random() * 0.9;
                    cRe = radius * Math.cos(theta) - 0.5;
                    cIm = radius * Math.sin(theta);
                } else if (r < 0.85) {
                    cRe = Math.random() * 3.5 - 2.5;
                    cIm = Math.random() * 3 - 1.5;
                } else {
                    cRe = -2 + Math.random() * 0.5;
                    cIm = (Math.random() - 0.5) * 0.2;
                }

                const q = (cRe - 0.25) * (cRe - 0.25) + cIm * cIm;
                if (q * (q + (cRe - 0.25)) < 0.25 * cIm * cIm) continue;
                if ((cRe + 1) * (cRe + 1) + cIm * cIm < 0.0625) continue;

                traceOrbitMinimap(cRe, cIm, 50, minimapImgB);
                traceOrbitMinimap(cRe, cIm, 500, minimapImgG);
                traceOrbitMinimap(cRe, cIm, 2000, minimapImgR);
            }
            minimapSamples += count;
        }

        function renderMinimap() {
            const imageData = minimapCtx.createImageData(MINIMAP_SIZE, MINIMAP_SIZE);

            let maxR = 0, maxG = 0, maxB = 0;
            for (let i = 0; i < minimapImgR.length; i++) {
                if (minimapImgR[i] > maxR) maxR = minimapImgR[i];
                if (minimapImgG[i] > maxG) maxG = minimapImgG[i];
                if (minimapImgB[i] > maxB) maxB = minimapImgB[i];
            }
            if (maxR === 0) maxR = 1;
            if (maxG === 0) maxG = 1;
            if (maxB === 0) maxB = 1;

            const logMaxR = Math.log(maxR + 1);
            const logMaxG = Math.log(maxG + 1);
            const logMaxB = Math.log(maxB + 1);
            const gamma = 0.4;

            for (let y = 0; y < MINIMAP_SIZE; y++) {
                for (let x = 0; x < MINIMAP_SIZE; x++) {
                    const idx = (y * MINIMAP_SIZE + x) * 4;
                    const pixIdx = y * MINIMAP_SIZE + x;

                    const vR = Math.pow(Math.log(minimapImgR[pixIdx] + 1) / logMaxR, gamma);
                    const vG = Math.pow(Math.log(minimapImgG[pixIdx] + 1) / logMaxG, gamma);
                    const vB = Math.pow(Math.log(minimapImgB[pixIdx] + 1) / logMaxB, gamma);

                    imageData.data[idx] = Math.min(255, vR * 255);
                    imageData.data[idx + 1] = Math.min(255, vG * 255);
                    imageData.data[idx + 2] = Math.min(255, vB * 255);
                    imageData.data[idx + 3] = 255;
                }
            }

            minimapCtx.putImageData(imageData, 0, 0);
            drawMinimapViewport();
        }

        function drawMinimapViewport() {
            if (!minimapReady) return;

            const imageData = minimapCtx.getImageData(0, 0, MINIMAP_SIZE, MINIMAP_SIZE);
            minimapCtx.putImageData(imageData, 0, 0);

            const x1 = (viewImMin - FULL_IM_MIN) / (FULL_IM_MAX - FULL_IM_MIN) * MINIMAP_SIZE;
            const x2 = (viewImMax - FULL_IM_MIN) / (FULL_IM_MAX - FULL_IM_MIN) * MINIMAP_SIZE;
            const y1 = (viewReMin - FULL_RE_MIN) / (FULL_RE_MAX - FULL_RE_MIN) * MINIMAP_SIZE;
            const y2 = (viewReMax - FULL_RE_MIN) / (FULL_RE_MAX - FULL_RE_MIN) * MINIMAP_SIZE;

            const rectX = Math.max(0, Math.min(x1, x2));
            const rectY = Math.max(0, Math.min(y1, y2));
            const rectW = Math.min(MINIMAP_SIZE - rectX, Math.abs(x2 - x1));
            const rectH = Math.min(MINIMAP_SIZE - rectY, Math.abs(y2 - y1));

            minimapCtx.strokeStyle = '#fff';
            minimapCtx.lineWidth = 2;
            minimapCtx.strokeRect(rectX, rectY, rectW, rectH);

            minimapCtx.fillStyle = 'rgba(255,255,255,0.1)';
            minimapCtx.fillRect(rectX, rectY, rectW, rectH);
        }

        function renderMinimapProgressive() {
            const targetSamples = 200000;
            const samplesPerFrame = 5000;

            function frame() {
                if (minimapSamples < targetSamples) {
                    generateMinimapSamples(samplesPerFrame);
                    renderMinimap();
                    requestAnimationFrame(frame);
                } else {
                    minimapReady = true;
                    renderMinimap();
                }
            }
            frame();
        }

        minimapCanvas.addEventListener('click', (e) => {
            const rect = minimapCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            viewCenterIm = FULL_IM_MIN + (x / MINIMAP_SIZE) * (FULL_IM_MAX - FULL_IM_MIN);
            viewCenterRe = FULL_RE_MIN + (y / MINIMAP_SIZE) * (FULL_RE_MAX - FULL_RE_MIN);

            startRender();
        });

        minimapCanvas.style.cursor = 'crosshair';

        initMinimap();
        startRender();

        // ===== How It Works Modal & Demo =====
        const modal = document.getElementById('howItWorksModal');
        const openBtn = document.getElementById('openHowItWorks');
        const closeBtn = document.getElementById('closeModal');

        let wasRenderingBeforeModal = false;

        openBtn.onclick = () => {
            // Pause main rendering for smooth scrolling
            wasRenderingBeforeModal = workers.length > 0;
            if (wasRenderingBeforeModal) {
                stopWorkers();
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
            }
            modal.classList.add('visible');
            initDemo();
        };

        function closeModal() {
            modal.classList.remove('visible');
            stopDemoAnimation();
            // Resume main rendering
            if (wasRenderingBeforeModal) {
                startRender();
            }
        }

        closeBtn.onclick = closeModal;

        modal.onclick = (e) => {
            if (e.target === modal) closeModal();
        };

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && modal.classList.contains('visible')) {
                closeModal();
            }
        });

        // Demo state
        const DEMO_SIZE = 400;
        const DEMO_RE_MIN = -2.0, DEMO_RE_MAX = 1.0;
        const DEMO_IM_MIN = -1.5, DEMO_IM_MAX = 1.5;

        let demoPlaneCanvas, demoPlaneCtx;
        let demoAccumCanvas, demoAccumCtx;
        let demoAccumData;
        let demoAnimationId = null;
        let demoEscapingCount = 0;
        let demoTotalHits = 0;
        let demoInitialized = false;

        function initDemo() {
            if (demoInitialized) return;
            demoInitialized = true;

            demoPlaneCanvas = document.getElementById('demo-plane');
            demoPlaneCtx = demoPlaneCanvas.getContext('2d');
            demoAccumCanvas = document.getElementById('demo-accum');
            demoAccumCtx = demoAccumCanvas.getContext('2d');

            demoAccumData = new Float32Array(DEMO_SIZE * DEMO_SIZE);

            drawDemoPlane();
            renderDemoAccum();

            // Event listeners
            demoPlaneCanvas.addEventListener('click', (e) => {
                const rect = demoPlaneCanvas.getBoundingClientRect();
                const scaleX = DEMO_SIZE / rect.width;
                const scaleY = DEMO_SIZE / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;

                const cIm = DEMO_IM_MIN + (x / DEMO_SIZE) * (DEMO_IM_MAX - DEMO_IM_MIN);
                const cRe = DEMO_RE_MIN + (y / DEMO_SIZE) * (DEMO_RE_MAX - DEMO_RE_MIN);

                traceAndShowOrbit(cRe, cIm);
            });

            document.getElementById('demo-random').onclick = () => {
                let cRe, cIm;
                do {
                    cRe = Math.random() * 3 - 2;
                    cIm = Math.random() * 3 - 1.5;
                    const q = (cRe - 0.25) ** 2 + cIm ** 2;
                    if (q * (q + (cRe - 0.25)) >= 0.25 * cIm ** 2 &&
                        (cRe + 1) ** 2 + cIm ** 2 >= 0.0625) break;
                } while (true);
                traceAndShowOrbit(cRe, cIm);
            };

            document.getElementById('demo-animate').onclick = startDemoAnimation;
            document.getElementById('demo-clear').onclick = () => {
                stopDemoAnimation();
                drawDemoPlane();
                document.getElementById('demo-info').textContent = 'Click to select a starting point c';
            };

            document.getElementById('demo-run100').onclick = () => {
                for (let i = 0; i < 100; i++) {
                    let cRe, cIm;
                    do {
                        cRe = Math.random() * 3 - 2;
                        cIm = Math.random() * 3 - 1.5;
                        const q = (cRe - 0.25) ** 2 + cIm ** 2;
                        if (q * (q + (cRe - 0.25)) >= 0.25 * cIm ** 2 &&
                            (cRe + 1) ** 2 + cIm ** 2 >= 0.0625) break;
                    } while (true);
                    traceDemoOrbit(cRe, cIm, true);
                }
                renderDemoAccum();
            };

            document.getElementById('demo-reset').onclick = () => {
                demoAccumData.fill(0);
                demoEscapingCount = 0;
                demoTotalHits = 0;
                renderDemoAccum();
            };
        }

        function drawDemoPlane() {
            // Draw Mandelbrot set boundary as reference
            const imageData = demoPlaneCtx.createImageData(DEMO_SIZE, DEMO_SIZE);

            for (let py = 0; py < DEMO_SIZE; py++) {
                for (let px = 0; px < DEMO_SIZE; px++) {
                    const cRe = DEMO_RE_MIN + (py / DEMO_SIZE) * (DEMO_RE_MAX - DEMO_RE_MIN);
                    const cIm = DEMO_IM_MIN + (px / DEMO_SIZE) * (DEMO_IM_MAX - DEMO_IM_MIN);

                    let zRe = 0, zIm = 0;
                    let iter = 0;
                    const maxIter = 100;

                    while (iter < maxIter && zRe * zRe + zIm * zIm <= 4) {
                        const temp = zRe * zRe - zIm * zIm + cRe;
                        zIm = 2 * zRe * zIm + cIm;
                        zRe = temp;
                        iter++;
                    }

                    const idx = (py * DEMO_SIZE + px) * 4;
                    if (iter === maxIter) {
                        // In set - dark
                        imageData.data[idx] = 20;
                        imageData.data[idx + 1] = 20;
                        imageData.data[idx + 2] = 30;
                    } else {
                        // Outside - gradient based on escape time
                        const t = iter / maxIter;
                        imageData.data[idx] = Math.floor(30 + t * 20);
                        imageData.data[idx + 1] = Math.floor(30 + t * 30);
                        imageData.data[idx + 2] = Math.floor(40 + t * 40);
                    }
                    imageData.data[idx + 3] = 255;
                }
            }

            demoPlaneCtx.putImageData(imageData, 0, 0);
        }

        function traceDemoOrbit(cRe, cIm, accumulate = false) {
            const maxIter = 500;
            const orbit = [];

            let zRe = 0, zIm = 0;

            for (let i = 0; i < maxIter; i++) {
                orbit.push({ re: zRe, im: zIm });

                const temp = zRe * zRe - zIm * zIm + cRe;
                zIm = 2 * zRe * zIm + cIm;
                zRe = temp;

                if (zRe * zRe + zIm * zIm > 4) {
                    // Escaping orbit
                    if (accumulate) {
                        demoEscapingCount++;
                        for (const p of orbit) {
                            if (p.re >= DEMO_RE_MIN && p.re <= DEMO_RE_MAX &&
                                p.im >= DEMO_IM_MIN && p.im <= DEMO_IM_MAX) {
                                const px = Math.floor((p.im - DEMO_IM_MIN) / (DEMO_IM_MAX - DEMO_IM_MIN) * (DEMO_SIZE - 1));
                                const py = Math.floor((p.re - DEMO_RE_MIN) / (DEMO_RE_MAX - DEMO_RE_MIN) * (DEMO_SIZE - 1));
                                if (px >= 0 && px < DEMO_SIZE && py >= 0 && py < DEMO_SIZE) {
                                    demoAccumData[py * DEMO_SIZE + px]++;
                                    demoTotalHits++;
                                }
                            }
                        }
                        updateAccumInfo();
                    }
                    return { orbit, escaped: true, iterations: i + 1 };
                }
            }

            return { orbit, escaped: false, iterations: maxIter };
        }

        function traceAndShowOrbit(cRe, cIm) {
            stopDemoAnimation();
            drawDemoPlane();

            const { orbit, escaped, iterations } = traceDemoOrbit(cRe, cIm, true);

            // Draw starting point
            const startX = (cIm - DEMO_IM_MIN) / (DEMO_IM_MAX - DEMO_IM_MIN) * DEMO_SIZE;
            const startY = (cRe - DEMO_RE_MIN) / (DEMO_RE_MAX - DEMO_RE_MIN) * DEMO_SIZE;

            demoPlaneCtx.fillStyle = '#ff0';
            demoPlaneCtx.beginPath();
            demoPlaneCtx.arc(startX, startY, 6, 0, Math.PI * 2);
            demoPlaneCtx.fill();

            // Draw orbit path
            demoPlaneCtx.strokeStyle = escaped ? 'rgba(100, 200, 150, 0.8)' : 'rgba(200, 80, 80, 0.8)';
            demoPlaneCtx.lineWidth = 1.5;
            demoPlaneCtx.beginPath();

            for (let i = 0; i < orbit.length; i++) {
                const px = (orbit[i].im - DEMO_IM_MIN) / (DEMO_IM_MAX - DEMO_IM_MIN) * DEMO_SIZE;
                const py = (orbit[i].re - DEMO_RE_MIN) / (DEMO_RE_MAX - DEMO_RE_MIN) * DEMO_SIZE;

                if (i === 0) demoPlaneCtx.moveTo(px, py);
                else demoPlaneCtx.lineTo(px, py);
            }
            demoPlaneCtx.stroke();

            // Draw orbit points
            for (let i = 0; i < Math.min(orbit.length, 50); i++) {
                const px = (orbit[i].im - DEMO_IM_MIN) / (DEMO_IM_MAX - DEMO_IM_MIN) * DEMO_SIZE;
                const py = (orbit[i].re - DEMO_RE_MIN) / (DEMO_RE_MAX - DEMO_RE_MIN) * DEMO_SIZE;

                const alpha = 1 - i / 50;
                demoPlaneCtx.fillStyle = escaped ?
                    `rgba(100, 255, 150, ${alpha})` :
                    `rgba(255, 100, 100, ${alpha})`;
                demoPlaneCtx.beginPath();
                demoPlaneCtx.arc(px, py, 3, 0, Math.PI * 2);
                demoPlaneCtx.fill();
            }

            // Update info
            const info = document.getElementById('demo-info');
            info.innerHTML = `c = ${cRe.toFixed(3)} + ${cIm.toFixed(3)}i<br>` +
                `<span class="${escaped ? 'escaping' : 'bounded'}">` +
                `${escaped ? `Escaping after ${iterations} iterations ✓` : `Bounded (in Mandelbrot set) ✗`}</span>`;

            renderDemoAccum();
        }

        function startDemoAnimation() {
            if (demoAnimationId) return;

            function animateFrame() {
                let cRe, cIm;
                do {
                    cRe = Math.random() * 3 - 2;
                    cIm = Math.random() * 3 - 1.5;
                    const q = (cRe - 0.25) ** 2 + cIm ** 2;
                    if (q * (q + (cRe - 0.25)) >= 0.25 * cIm ** 2 &&
                        (cRe + 1) ** 2 + cIm ** 2 >= 0.0625) break;
                } while (true);

                traceAndShowOrbit(cRe, cIm);
                demoAnimationId = setTimeout(animateFrame, 800);
            }

            animateFrame();
        }

        function stopDemoAnimation() {
            if (demoAnimationId) {
                clearTimeout(demoAnimationId);
                demoAnimationId = null;
            }
        }

        function renderDemoAccum() {
            const imageData = demoAccumCtx.createImageData(DEMO_SIZE, DEMO_SIZE);

            let maxVal = 0;
            for (let i = 0; i < demoAccumData.length; i++) {
                if (demoAccumData[i] > maxVal) maxVal = demoAccumData[i];
            }
            if (maxVal === 0) maxVal = 1;

            const logMax = Math.log(maxVal + 1);

            for (let y = 0; y < DEMO_SIZE; y++) {
                for (let x = 0; x < DEMO_SIZE; x++) {
                    const idx = (y * DEMO_SIZE + x) * 4;
                    const val = demoAccumData[y * DEMO_SIZE + x];

                    const normalized = Math.log(val + 1) / logMax;
                    const v = Math.pow(normalized, 0.5);

                    // Cyan-ish color scheme
                    imageData.data[idx] = Math.floor(v * 100);
                    imageData.data[idx + 1] = Math.floor(v * 200);
                    imageData.data[idx + 2] = Math.floor(v * 255);
                    imageData.data[idx + 3] = 255;
                }
            }

            demoAccumCtx.putImageData(imageData, 0, 0);
            updateAccumInfo();
        }

        function updateAccumInfo() {
            document.getElementById('accum-info').textContent =
                `Escaping orbits: ${demoEscapingCount} | Total hits: ${demoTotalHits.toLocaleString()}`;
        }
    </script>
</body>
</html>
