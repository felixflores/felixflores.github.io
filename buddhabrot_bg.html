<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Buddhabrot Background</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100vh;
        }
        
        #buddhabrot-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        
        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            color: white;
            font-family: monospace;
            font-size: 12px;
            z-index: 100;
            min-width: 220px;
        }

        .controls h3 {
            margin: 0 0 15px 0;
            font-size: 14px;
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group label {
            display: block;
            margin-bottom: 4px;
            color: #aaa;
        }

        .control-group input[type="range"] {
            width: 100%;
        }

        .control-group select {
            width: 100%;
            padding: 4px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
        }

        .control-group .value {
            float: right;
            color: #f90;
        }

        button {
            width: 100%;
            padding: 8px;
            margin-top: 10px;
            background: #f90;
            color: black;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        button:hover {
            background: #fa0;
        }

        #status {
            margin-top: 10px;
            color: #888;
            font-size: 11px;
        }

        #buddhabrot-canvas {
            cursor: grab;
        }

        #buddhabrot-canvas:active {
            cursor: grabbing;
        }

        .zoom-hint {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: rgba(0,0,0,0.6);
            padding: 10px 15px;
            border-radius: 6px;
            color: #888;
            font-family: monospace;
            font-size: 11px;
            z-index: 100;
        }

        .minimap-container {
            position: fixed;
            bottom: 80px;
            right: 30px;
            background: rgba(0,0,0,0.8);
            padding: 8px;
            border-radius: 8px;
            z-index: 100;
        }

        .minimap-container canvas {
            display: block;
            border-radius: 4px;
        }

        .minimap-label {
            color: #666;
            font-family: monospace;
            font-size: 10px;
            margin-top: 5px;
            text-align: center;
        }

        .info {
            position: fixed;
            bottom: 30px;
            left: 30px;
            max-width: 400px;
            background: rgba(0,0,0,0.75);
            padding: 20px 25px;
            border-radius: 10px;
            color: #ccc;
            font-family: Georgia, serif;
            font-size: 15px;
            line-height: 1.6;
            z-index: 100;
        }

        .info h2 {
            margin: 0 0 12px 0;
            color: #fff;
            font-size: 18px;
            font-weight: normal;
        }

        .info p {
            margin: 0;
        }

        .equation {
            text-align: center;
            margin: 18px 0 14px 0;
            font-family: 'Times New Roman', Times, serif;
            font-size: 26px;
            font-style: italic;
            color: #fff;
            letter-spacing: 2px;
        }

        .equation sup {
            font-size: 16px;
            vertical-align: super;
        }

        .equation sub {
            font-size: 14px;
            vertical-align: sub;
            color: #999;
        }
    </style>
</head>
<body>
    <canvas id="buddhabrot-canvas"></canvas>

    <div class="info">
        <h2>The Buddhabrot</h2>
        <p>This ghostly figure emerges from a simple equation repeated millions of times:</p>
        <div class="equation">z<sub>n+1</sub> = z<sub>n</sub><sup>2</sup> + c</div>
        <p>Each point follows a path through an imaginary number space—some spiral inward forever, others escape to infinity. By tracing only the escaping paths and recording where they wander, this Buddha-like shape appears. The colors show depth: blue traces short journeys, green medium ones, and red the longest voyages before escape. No one designed this. It was discovered hiding in pure mathematics.</p>
    </div>

    <div class="controls">
        <h3>Nebulabrot</h3>

        <div class="control-group">
            <label>Quality</label>
            <select id="quality">
                <option value="preview">Preview (fast)</option>
                <option value="medium" selected>Medium</option>
                <option value="high">High (slow)</option>
            </select>
        </div>

        <div class="control-group">
            <label>Noise Floor <span class="value" id="floorVal">0</span></label>
            <input type="range" id="noiseFloor" min="0" max="50" step="1" value="0">
        </div>

        <div class="control-group">
            <label>Exposure <span class="value" id="exposureVal">0</span></label>
            <input type="range" id="exposure" min="-3" max="3" step="0.1" value="0">
        </div>

        <div class="control-group">
            <label>Contrast <span class="value" id="contrastVal">1.0</span></label>
            <input type="range" id="contrast" min="0.5" max="2.0" step="0.1" value="1.0">
        </div>

        <div class="control-group">
            <label>Highlight Compression <span class="value" id="compressVal">0.5</span></label>
            <input type="range" id="compress" min="0.1" max="1.0" step="0.05" value="0.5">
        </div>

        <button id="regenerate">Regenerate</button>
        <button id="resetView" style="background:#666; margin-top:5px;">Reset View</button>
        <button id="download" style="background:#4a9; margin-top:5px;">Download PNG</button>
        <button id="copyLink" style="background:#68c; margin-top:5px;">Copy Link</button>
        <div id="status">Ready</div>
        <div id="zoomLevel" style="margin-top:8px; color:#666;">Zoom: 1.0x</div>
    </div>

    <div class="minimap-container">
        <canvas id="minimap" width="150" height="150"></canvas>
        <div class="minimap-label">Overview</div>
    </div>

    <div class="zoom-hint">
        Scroll to zoom · Drag to pan
    </div>

    <script>
        const canvas = document.getElementById('buddhabrot-canvas');
        let ctx = canvas.getContext('2d');

        // Minimap
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        const MINIMAP_SIZE = 150;
        let minimapImgR = null, minimapImgG = null, minimapImgB = null;
        let minimapReady = false;
        let minimapSamples = 0;

        // Full view bounds for minimap (what zoom=1 shows)
        const FULL_RE_MIN = -2.0, FULL_RE_MAX = 1.0;
        const FULL_IM_MIN = -1.5, FULL_IM_MAX = 1.5;

        // Three channels for Nebulabrot (R=high iter, G=mid iter, B=low iter)
        let imgR = null, imgG = null, imgB = null;
        let width, height;

        // Preview canvas for smooth panning
        const previewCanvas = document.createElement('canvas');
        const previewCtx = previewCanvas.getContext('2d');
        let lastViewState = null; // Store previous view for transform calculation

        // Parallel workers - persistent, send frequent small updates
        const numWorkers = navigator.hardwareConcurrency || 8;
        let workers = [];
        let isRendering = false;

        // Worker code - sends small updates frequently for smooth rendering
        const workerCode = `
            const ITER_R = 20000;
            const ITER_G = 2000;
            const ITER_B = 200;
            const UPDATE_INTERVAL = 2000; // Send update every N samples

            let width, height;
            let viewReMin, viewReMax, viewImMin, viewImMax;
            let imgR, imgG, imgB;
            let localSamples = 0;
            let running = false;

            function traceOrbit(cRe, cIm, maxIter, hits) {
                let zRe = 0, zIm = 0;
                const orbitRe = new Float64Array(maxIter);
                const orbitIm = new Float64Array(maxIter);
                let orbitLen = 0;

                for (let i = 0; i < maxIter; i++) {
                    orbitRe[orbitLen] = zRe;
                    orbitIm[orbitLen] = zIm;
                    orbitLen++;

                    const zRe2 = zRe * zRe - zIm * zIm + cRe;
                    const zIm2 = 2 * zRe * zIm + cIm;
                    zRe = zRe2;
                    zIm = zIm2;

                    if (zRe * zRe + zIm * zIm > 4) break;
                }

                if (orbitLen < maxIter) {
                    for (let i = 0; i < orbitLen; i++) {
                        const pRe = orbitRe[i];
                        const pIm = orbitIm[i];

                        if (pRe >= viewReMin && pRe <= viewReMax && pIm >= viewImMin && pIm <= viewImMax) {
                            const x = Math.floor((pIm - viewImMin) / (viewImMax - viewImMin) * (width - 1));
                            const y = Math.floor((pRe - viewReMin) / (viewReMax - viewReMin) * (height - 1));

                            if (x >= 0 && x < width && y >= 0 && y < height) {
                                hits[y * width + x]++;
                            }
                        }
                    }
                }
            }

            function runSampling() {
                if (!running) return;

                const samplePadding = 2.0;
                const sampleReMin = Math.max(-2.5, viewReMin - samplePadding);
                const sampleReMax = Math.min(1.5, viewReMax + samplePadding);
                const sampleImMin = Math.max(-2.0, viewImMin - samplePadding);
                const sampleImMax = Math.min(2.0, viewImMax + samplePadding);

                for (let s = 0; s < UPDATE_INTERVAL; s++) {
                    let cRe, cIm;

                    const r = Math.random();
                    if (r < 0.6) {
                        const theta = Math.random() * Math.PI * 2;
                        const radius = 0.3 + Math.random() * 0.9;
                        cRe = radius * Math.cos(theta) - 0.5;
                        cIm = radius * Math.sin(theta);
                    } else if (r < 0.85) {
                        cRe = Math.random() * (sampleReMax - sampleReMin) + sampleReMin;
                        cIm = Math.random() * (sampleImMax - sampleImMin) + sampleImMin;
                    } else {
                        cRe = -2 + Math.random() * 0.5;
                        cIm = (Math.random() - 0.5) * 0.2;
                    }

                    const q = (cRe - 0.25) * (cRe - 0.25) + cIm * cIm;
                    if (q * (q + (cRe - 0.25)) < 0.25 * cIm * cIm) continue;
                    if ((cRe + 1) * (cRe + 1) + cIm * cIm < 0.0625) continue;

                    traceOrbit(cRe, cIm, ITER_B, imgB);
                    traceOrbit(cRe, cIm, ITER_G, imgG);
                    traceOrbit(cRe, cIm, ITER_R, imgR);
                }
                localSamples += UPDATE_INTERVAL;

                // Send incremental update
                self.postMessage({
                    type: 'update',
                    samples: UPDATE_INTERVAL,
                    imgR: imgR,
                    imgG: imgG,
                    imgB: imgB
                });

                // Reset local accumulators
                imgR = new Float32Array(width * height);
                imgG = new Float32Array(width * height);
                imgB = new Float32Array(width * height);

                // Continue sampling
                setTimeout(runSampling, 0);
            }

            self.onmessage = function(e) {
                const { type, data } = e.data;

                if (type === 'init') {
                    width = data.width;
                    height = data.height;
                    viewReMin = data.viewReMin;
                    viewReMax = data.viewReMax;
                    viewImMin = data.viewImMin;
                    viewImMax = data.viewImMax;
                    imgR = new Float32Array(width * height);
                    imgG = new Float32Array(width * height);
                    imgB = new Float32Array(width * height);
                    localSamples = 0;
                    self.postMessage({ type: 'ready' });
                } else if (type === 'start') {
                    running = true;
                    runSampling();
                } else if (type === 'stop') {
                    running = false;
                }
            };
        `;

        const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(workerBlob);

        function initWorkers() {
            workers.forEach(w => w.terminate());
            workers = [];

            for (let i = 0; i < numWorkers; i++) {
                const worker = new Worker(workerUrl);
                worker.onmessage = handleWorkerMessage;
                workers.push(worker);
            }
        }

        let workersReady = 0;
        function handleWorkerMessage(e) {
            const { type, samples, imgR: wR, imgG: wG, imgB: wB } = e.data;

            if (type === 'ready') {
                workersReady++;
                if (workersReady === numWorkers) {
                    // All ready, start them all
                    workers.forEach(w => w.postMessage({ type: 'start' }));
                }
            } else if (type === 'update') {
                // Accumulate from this worker
                for (let i = 0; i < imgR.length; i++) {
                    imgR[i] += wR[i];
                    imgG[i] += wG[i];
                    imgB[i] += wB[i];
                }
                totalSamples += samples;
            }
        }

        function stopWorkers() {
            workers.forEach(w => w.postMessage({ type: 'stop' }));
        }

        // View bounds (what we're currently showing)
        let viewReMin, viewReMax, viewImMin, viewImMax;

        // View state
        let viewCenterRe = -0.5;  // Center in real axis
        let viewCenterIm = 0;     // Center in imaginary axis
        let zoom = 1.0;

        let animationId = null;
        let totalSamples = 0;

        // Iteration counts for each channel
        const ITER_R = 20000;
        const ITER_G = 2000;
        const ITER_B = 200;

        // Controls
        const qualitySelect = document.getElementById('quality');
        const noiseFloorSlider = document.getElementById('noiseFloor');
        const exposureSlider = document.getElementById('exposure');
        const contrastSlider = document.getElementById('contrast');
        const compressSlider = document.getElementById('compress');
        const regenerateBtn = document.getElementById('regenerate');
        const resetViewBtn = document.getElementById('resetView');
        const statusEl = document.getElementById('status');
        const zoomLevelEl = document.getElementById('zoomLevel');

        noiseFloorSlider.oninput = () => {
            document.getElementById('floorVal').textContent = noiseFloorSlider.value;
            render();
            saveToStorage();
        };
        exposureSlider.oninput = () => {
            document.getElementById('exposureVal').textContent = exposureSlider.value;
            render();
            saveToStorage();
        };
        contrastSlider.oninput = () => {
            document.getElementById('contrastVal').textContent = contrastSlider.value;
            render();
            saveToStorage();
        };
        compressSlider.oninput = () => {
            document.getElementById('compressVal').textContent = compressSlider.value;
            render();
            saveToStorage();
        };
        qualitySelect.onchange = () => saveToStorage();
        regenerateBtn.onclick = () => startRender();
        resetViewBtn.onclick = () => {
            viewCenterRe = -0.5;
            viewCenterIm = 0;
            zoom = 1.0;
            startRender();
        };
        document.getElementById('download').onclick = () => {
            // Create composite canvas with minimap
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = canvas.width;
            exportCanvas.height = canvas.height;
            const exportCtx = exportCanvas.getContext('2d');

            // Draw main render
            exportCtx.drawImage(canvas, 0, 0);

            // Draw minimap in bottom-right corner with padding
            const padding = 20;
            const minimapX = canvas.width - MINIMAP_SIZE - padding;
            const minimapY = canvas.height - MINIMAP_SIZE - padding;

            // Draw minimap background
            exportCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            exportCtx.roundRect(minimapX - 8, minimapY - 8, MINIMAP_SIZE + 16, MINIMAP_SIZE + 16, 8);
            exportCtx.fill();

            // Draw minimap
            exportCtx.drawImage(minimapCanvas, minimapX, minimapY);

            // Draw "Overview" label
            exportCtx.fillStyle = '#666';
            exportCtx.font = '10px monospace';
            exportCtx.textAlign = 'center';
            exportCtx.fillText('Overview', minimapX + MINIMAP_SIZE / 2, minimapY + MINIMAP_SIZE + 14);

            const link = document.createElement('a');
            link.download = `nebulabrot-${zoom.toFixed(1)}x-${Date.now()}.png`;
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
        };

        document.getElementById('copyLink').onclick = () => {
            const params = new URLSearchParams({
                re: viewCenterRe.toFixed(10),
                im: viewCenterIm.toFixed(10),
                z: zoom.toFixed(4),
                floor: noiseFloorSlider.value,
                exp: exposureSlider.value,
                con: contrastSlider.value,
                comp: compressSlider.value,
                q: qualitySelect.value
            });
            const url = `${window.location.origin}${window.location.pathname}?${params}`;
            navigator.clipboard.writeText(url).then(() => {
                const btn = document.getElementById('copyLink');
                btn.textContent = 'Copied!';
                btn.style.background = '#4a9';
                setTimeout(() => {
                    btn.textContent = 'Copy Link';
                    btn.style.background = '#68c';
                }, 2000);
            });
        };

        // Load state from URL parameters
        function loadFromURL() {
            const params = new URLSearchParams(window.location.search);
            if (params.has('re')) viewCenterRe = parseFloat(params.get('re'));
            if (params.has('im')) viewCenterIm = parseFloat(params.get('im'));
            if (params.has('z')) zoom = parseFloat(params.get('z'));
            if (params.has('floor')) {
                noiseFloorSlider.value = params.get('floor');
                document.getElementById('floorVal').textContent = params.get('floor');
            }
            if (params.has('exp')) {
                exposureSlider.value = params.get('exp');
                document.getElementById('exposureVal').textContent = params.get('exp');
            }
            if (params.has('con')) {
                contrastSlider.value = params.get('con');
                document.getElementById('contrastVal').textContent = params.get('con');
            }
            if (params.has('comp')) {
                compressSlider.value = params.get('comp');
                document.getElementById('compressVal').textContent = params.get('comp');
            }
            if (params.has('q')) qualitySelect.value = params.get('q');
        }

        // Load from localStorage (URL params override)
        function loadFromStorage() {
            const saved = localStorage.getItem('buddhabrot-view');
            if (saved) {
                try {
                    const state = JSON.parse(saved);
                    viewCenterRe = state.re ?? viewCenterRe;
                    viewCenterIm = state.im ?? viewCenterIm;
                    zoom = state.z ?? zoom;
                    if (state.floor !== undefined) {
                        noiseFloorSlider.value = state.floor;
                        document.getElementById('floorVal').textContent = state.floor;
                    }
                    if (state.exp !== undefined) {
                        exposureSlider.value = state.exp;
                        document.getElementById('exposureVal').textContent = state.exp;
                    }
                    if (state.con !== undefined) {
                        contrastSlider.value = state.con;
                        document.getElementById('contrastVal').textContent = state.con;
                    }
                    if (state.comp !== undefined) {
                        compressSlider.value = state.comp;
                        document.getElementById('compressVal').textContent = state.comp;
                    }
                    if (state.q) qualitySelect.value = state.q;
                } catch (e) {}
            }
        }

        function saveToStorage() {
            const state = {
                re: viewCenterRe,
                im: viewCenterIm,
                z: zoom,
                floor: noiseFloorSlider.value,
                exp: exposureSlider.value,
                con: contrastSlider.value,
                comp: compressSlider.value,
                q: qualitySelect.value
            };
            localStorage.setItem('buddhabrot-view', JSON.stringify(state));

            // Update URL for easy sharing
            const params = new URLSearchParams({
                re: viewCenterRe.toFixed(10),
                im: viewCenterIm.toFixed(10),
                z: zoom.toFixed(4),
                floor: noiseFloorSlider.value,
                exp: exposureSlider.value,
                con: contrastSlider.value,
                comp: compressSlider.value,
                q: qualitySelect.value
            });
            history.replaceState(null, '', `?${params}`);
        }

        // Load storage first, then URL params override
        loadFromStorage();
        loadFromURL();

        function updateViewBounds() {
            const baseHeight = 3.0;
            const baseWidth = 3.0;
            const screenAspect = width / height;

            let viewHeight = baseHeight / zoom;
            let viewWidth = viewHeight * screenAspect;

            // View bounds (rotated: re is vertical, im is horizontal)
            viewReMin = viewCenterRe - viewHeight / 2;
            viewReMax = viewCenterRe + viewHeight / 2;
            viewImMin = viewCenterIm - viewWidth / 2;
            viewImMax = viewCenterIm + viewWidth / 2;

            zoomLevelEl.textContent = `Zoom: ${zoom.toFixed(1)}x`;

            // Update minimap viewport indicator
            if (minimapReady) {
                renderMinimap();
            }
        }

        function startRender() {
            if (animationId) cancelAnimationFrame(animationId);
            stopWorkers();

            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight;

            // Save current view state for preview transform
            if (width && height && imgR && totalSamples > 0) {
                lastViewState = {
                    viewReMin, viewReMax, viewImMin, viewImMax,
                    width, height
                };
                // Copy current canvas to preview
                previewCanvas.width = width;
                previewCanvas.height = height;
                previewCtx.drawImage(canvas, 0, 0);
            }

            canvas.width = newWidth;
            canvas.height = newHeight;
            width = newWidth;
            height = newHeight;

            updateViewBounds();
            saveToStorage();

            // Show transformed preview immediately
            if (lastViewState) {
                drawTransformedPreview();
            }

            // Reset RGB channels
            imgR = new Float32Array(width * height);
            imgG = new Float32Array(width * height);
            imgB = new Float32Array(width * height);
            totalSamples = 0;
            workersReady = 0;

            // Initialize and start workers
            initWorkers();
            for (const worker of workers) {
                worker.postMessage({
                    type: 'init',
                    data: { width, height, viewReMin, viewReMax, viewImMin, viewImMax }
                });
            }

            // Start render loop
            renderLoop();
        }

        function renderLoop() {
            const quality = qualitySelect.value;
            const zoomFactor = Math.max(1, Math.sqrt(zoom));
            const targets = {
                preview: Math.floor(500000 * zoomFactor),
                medium: Math.floor(3000000 * zoomFactor),
                high: Math.floor(15000000 * zoomFactor)
            };
            const targetSamples = targets[quality];

            function frame() {
                render();
                const pct = Math.round(totalSamples / targetSamples * 100);
                statusEl.textContent = `${Math.min(100, pct)}% (${(totalSamples/1000000).toFixed(1)}M) [${numWorkers} cores]`;

                if (totalSamples < targetSamples) {
                    animationId = requestAnimationFrame(frame);
                } else {
                    stopWorkers();
                    statusEl.textContent = `Done: ${(totalSamples/1000000).toFixed(1)}M samples [${numWorkers} cores]`;
                }
            }
            frame();
        }

        function drawTransformedPreview() {
            if (!lastViewState) return;

            const old = lastViewState;

            // Calculate how the old view maps to the new view
            // Map old pixel coords to complex coords, then to new pixel coords
            const oldImRange = old.viewImMax - old.viewImMin;
            const oldReRange = old.viewReMax - old.viewReMin;
            const newImRange = viewImMax - viewImMin;
            const newReRange = viewReMax - viewReMin;

            // Scale factors
            const scaleX = (oldImRange / newImRange) * (width / old.width);
            const scaleY = (oldReRange / newReRange) * (height / old.height);

            // Offset: where does the old view's top-left appear in new coords?
            const offsetX = ((old.viewImMin - viewImMin) / newImRange) * width;
            const offsetY = ((old.viewReMin - viewReMin) / newReRange) * height;

            // Draw transformed preview with slight dimming to indicate it's a preview
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            ctx.globalAlpha = 0.6;
            ctx.drawImage(previewCanvas, offsetX, offsetY, old.width * scaleX, old.height * scaleY);
            ctx.globalAlpha = 1.0;
        }

        window.addEventListener('resize', startRender);

        function render() {
            const noiseFloor = parseInt(noiseFloorSlider.value);
            const exposure = parseFloat(exposureSlider.value);
            const contrast = parseFloat(contrastSlider.value);
            const compress = parseFloat(compressSlider.value);

            const imageData = ctx.createImageData(width, height);

            // Find max for each channel (ignoring noise floor)
            let maxR = 0, maxG = 0, maxB = 0;
            for (let i = 0; i < imgR.length; i++) {
                if (imgR[i] > noiseFloor && imgR[i] > maxR) maxR = imgR[i];
                if (imgG[i] > noiseFloor && imgG[i] > maxG) maxG = imgG[i];
                if (imgB[i] > noiseFloor && imgB[i] > maxB) maxB = imgB[i];
            }
            if (maxR === 0) maxR = 1;
            if (maxG === 0) maxG = 1;
            if (maxB === 0) maxB = 1;

            // Exposure multiplier (2^exposure gives photographer-style stops)
            const expMult = Math.pow(2, exposure);

            // Tone mapping function with highlight compression
            function toneMap(val, max) {
                if (val <= noiseFloor) return 0;

                // Normalize to 0-1 range using log scale
                const normalized = Math.log(val - noiseFloor + 1) / Math.log(max - noiseFloor + 1);

                // Apply contrast around midpoint
                const midpoint = 0.5;
                let contrasted = midpoint + (normalized - midpoint) * contrast;
                contrasted = Math.max(0, Math.min(1, contrasted));

                // Apply exposure
                let exposed = contrasted * expMult;

                // Soft highlight compression (Reinhard-style tone mapping)
                // compress controls how aggressively highlights are compressed
                // Lower compress = more compression (preserves highlights)
                const compressed = exposed / (exposed + compress);

                return Math.min(1, compressed / (1 / (1 + compress))); // Normalize so 1 maps to 1
            }

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const pixIdx = y * width + x;

                    const vR = toneMap(imgR[pixIdx], maxR);
                    const vG = toneMap(imgG[pixIdx], maxG);
                    const vB = toneMap(imgB[pixIdx], maxB);

                    imageData.data[idx] = Math.floor(vR * 255);
                    imageData.data[idx + 1] = Math.floor(vG * 255);
                    imageData.data[idx + 2] = Math.floor(vB * 255);
                    imageData.data[idx + 3] = 255;
                }
            }

            // If we have a preview and not much new data yet, blend them
            const quality = qualitySelect.value;
            const zoomFactor = Math.max(1, Math.sqrt(zoom));
            const targets = {
                preview: Math.floor(500000 * zoomFactor),
                medium: Math.floor(3000000 * zoomFactor),
                high: Math.floor(15000000 * zoomFactor)
            };
            const targetSamples = targets[quality];
            const progress = Math.min(1, totalSamples / (targetSamples * 0.1)); // Fade preview over first 10%

            if (lastViewState && progress < 1) {
                // Draw transformed preview first
                drawTransformedPreview();
                // Create temp canvas for new data
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.putImageData(imageData, 0, 0);
                // Blend new data on top with increasing opacity
                ctx.globalAlpha = progress;
                ctx.drawImage(tempCanvas, 0, 0);
                ctx.globalAlpha = 1.0;
            } else {
                ctx.putImageData(imageData, 0, 0);
            }
        }

        // ===== Pan and Zoom Controls =====

        let isDragging = false;
        let dragStartX, dragStartY;
        let dragStartCenterRe, dragStartCenterIm;

        canvas.addEventListener('mousedown', (e) => {
            if (e.target !== canvas) return;
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            dragStartCenterRe = viewCenterRe;
            dragStartCenterIm = viewCenterIm;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            const dx = e.clientX - dragStartX;
            const dy = e.clientY - dragStartY;

            // Convert pixel movement to complex plane movement
            const viewHeight = (viewReMax - viewReMin);
            const viewWidth = (viewImMax - viewImMin);

            viewCenterIm = dragStartCenterIm - (dx / width) * viewWidth;
            viewCenterRe = dragStartCenterRe - (dy / height) * viewHeight;

            updateViewBounds();
            startRender();
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();

            // Get mouse position in complex plane before zoom
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const mouseIm = viewImMin + (mouseX / width) * (viewImMax - viewImMin);
            const mouseRe = viewReMin + (mouseY / height) * (viewReMax - viewReMin);

            // Zoom in/out
            const zoomFactor = e.deltaY > 0 ? 0.8 : 1.25;
            const newZoom = Math.max(0.5, Math.min(1000, zoom * zoomFactor));

            if (newZoom !== zoom) {
                // Adjust center to zoom toward mouse position
                const zoomRatio = zoom / newZoom;
                viewCenterRe = mouseRe + (viewCenterRe - mouseRe) * zoomRatio;
                viewCenterIm = mouseIm + (viewCenterIm - mouseIm) * zoomRatio;
                zoom = newZoom;

                startRender();
            }
        }, { passive: false });

        // Touch support for mobile
        let lastTouchDist = 0;
        let lastTouchCenter = null;

        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isDragging = true;
                dragStartX = e.touches[0].clientX;
                dragStartY = e.touches[0].clientY;
                dragStartCenterRe = viewCenterRe;
                dragStartCenterIm = viewCenterIm;
            } else if (e.touches.length === 2) {
                isDragging = false;
                const dx = e.touches[1].clientX - e.touches[0].clientX;
                const dy = e.touches[1].clientY - e.touches[0].clientY;
                lastTouchDist = Math.sqrt(dx * dx + dy * dy);
                lastTouchCenter = {
                    x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                    y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                };
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();

            if (e.touches.length === 1 && isDragging) {
                const dx = e.touches[0].clientX - dragStartX;
                const dy = e.touches[0].clientY - dragStartY;

                const viewHeight = (viewReMax - viewReMin);
                const viewWidth = (viewImMax - viewImMin);

                viewCenterIm = dragStartCenterIm - (dx / width) * viewWidth;
                viewCenterRe = dragStartCenterRe - (dy / height) * viewHeight;

                updateViewBounds();
                startRender();
            } else if (e.touches.length === 2 && lastTouchDist > 0) {
                const dx = e.touches[1].clientX - e.touches[0].clientX;
                const dy = e.touches[1].clientY - e.touches[0].clientY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                const zoomFactor = dist / lastTouchDist;
                const newZoom = Math.max(0.5, Math.min(1000, zoom * zoomFactor));

                if (newZoom !== zoom) {
                    zoom = newZoom;
                    lastTouchDist = dist;
                    startRender();
                }
            }
        }, { passive: false });

        canvas.addEventListener('touchend', () => {
            isDragging = false;
            lastTouchDist = 0;
        });

        // ===== Minimap =====

        function initMinimap() {
            minimapImgR = new Float32Array(MINIMAP_SIZE * MINIMAP_SIZE);
            minimapImgG = new Float32Array(MINIMAP_SIZE * MINIMAP_SIZE);
            minimapImgB = new Float32Array(MINIMAP_SIZE * MINIMAP_SIZE);
            minimapSamples = 0;
            minimapReady = false;
            renderMinimapProgressive();
        }

        function traceOrbitMinimap(cRe, cIm, maxIter, imgArray) {
            let zRe = 0, zIm = 0;
            const orbitRe = new Float64Array(maxIter);
            const orbitIm = new Float64Array(maxIter);
            let orbitLen = 0;

            for (let i = 0; i < maxIter; i++) {
                orbitRe[orbitLen] = zRe;
                orbitIm[orbitLen] = zIm;
                orbitLen++;

                const zRe2 = zRe * zRe - zIm * zIm + cRe;
                const zIm2 = 2 * zRe * zIm + cIm;
                zRe = zRe2;
                zIm = zIm2;

                if (zRe * zRe + zIm * zIm > 4) break;
            }

            if (orbitLen < maxIter) {
                for (let i = 0; i < orbitLen; i++) {
                    const pRe = orbitRe[i];
                    const pIm = orbitIm[i];

                    if (pRe >= FULL_RE_MIN && pRe <= FULL_RE_MAX && pIm >= FULL_IM_MIN && pIm <= FULL_IM_MAX) {
                        const x = Math.floor((pIm - FULL_IM_MIN) / (FULL_IM_MAX - FULL_IM_MIN) * (MINIMAP_SIZE - 1));
                        const y = Math.floor((pRe - FULL_RE_MIN) / (FULL_RE_MAX - FULL_RE_MIN) * (MINIMAP_SIZE - 1));

                        if (x >= 0 && x < MINIMAP_SIZE && y >= 0 && y < MINIMAP_SIZE) {
                            imgArray[y * MINIMAP_SIZE + x]++;
                        }
                    }
                }
            }
        }

        function generateMinimapSamples(count) {
            for (let s = 0; s < count; s++) {
                let cRe, cIm;
                const r = Math.random();
                if (r < 0.6) {
                    const theta = Math.random() * Math.PI * 2;
                    const radius = 0.3 + Math.random() * 0.9;
                    cRe = radius * Math.cos(theta) - 0.5;
                    cIm = radius * Math.sin(theta);
                } else if (r < 0.85) {
                    cRe = Math.random() * 3.5 - 2.5;
                    cIm = Math.random() * 3 - 1.5;
                } else {
                    cRe = -2 + Math.random() * 0.5;
                    cIm = (Math.random() - 0.5) * 0.2;
                }

                const q = (cRe - 0.25) * (cRe - 0.25) + cIm * cIm;
                if (q * (q + (cRe - 0.25)) < 0.25 * cIm * cIm) continue;
                if ((cRe + 1) * (cRe + 1) + cIm * cIm < 0.0625) continue;

                traceOrbitMinimap(cRe, cIm, 50, minimapImgB);
                traceOrbitMinimap(cRe, cIm, 500, minimapImgG);
                traceOrbitMinimap(cRe, cIm, 2000, minimapImgR);
            }
            minimapSamples += count;
        }

        function renderMinimap() {
            const imageData = minimapCtx.createImageData(MINIMAP_SIZE, MINIMAP_SIZE);

            let maxR = 0, maxG = 0, maxB = 0;
            for (let i = 0; i < minimapImgR.length; i++) {
                if (minimapImgR[i] > maxR) maxR = minimapImgR[i];
                if (minimapImgG[i] > maxG) maxG = minimapImgG[i];
                if (minimapImgB[i] > maxB) maxB = minimapImgB[i];
            }
            if (maxR === 0) maxR = 1;
            if (maxG === 0) maxG = 1;
            if (maxB === 0) maxB = 1;

            const logMaxR = Math.log(maxR + 1);
            const logMaxG = Math.log(maxG + 1);
            const logMaxB = Math.log(maxB + 1);
            const gamma = 0.4;

            for (let y = 0; y < MINIMAP_SIZE; y++) {
                for (let x = 0; x < MINIMAP_SIZE; x++) {
                    const idx = (y * MINIMAP_SIZE + x) * 4;
                    const pixIdx = y * MINIMAP_SIZE + x;

                    const vR = Math.pow(Math.log(minimapImgR[pixIdx] + 1) / logMaxR, gamma);
                    const vG = Math.pow(Math.log(minimapImgG[pixIdx] + 1) / logMaxG, gamma);
                    const vB = Math.pow(Math.log(minimapImgB[pixIdx] + 1) / logMaxB, gamma);

                    imageData.data[idx] = Math.min(255, vR * 255);
                    imageData.data[idx + 1] = Math.min(255, vG * 255);
                    imageData.data[idx + 2] = Math.min(255, vB * 255);
                    imageData.data[idx + 3] = 255;
                }
            }

            minimapCtx.putImageData(imageData, 0, 0);
            drawMinimapViewport();
        }

        function drawMinimapViewport() {
            if (!minimapReady) return;

            // Redraw the minimap base
            const imageData = minimapCtx.getImageData(0, 0, MINIMAP_SIZE, MINIMAP_SIZE);
            minimapCtx.putImageData(imageData, 0, 0);

            // Calculate viewport rectangle in minimap coordinates
            const x1 = (viewImMin - FULL_IM_MIN) / (FULL_IM_MAX - FULL_IM_MIN) * MINIMAP_SIZE;
            const x2 = (viewImMax - FULL_IM_MIN) / (FULL_IM_MAX - FULL_IM_MIN) * MINIMAP_SIZE;
            const y1 = (viewReMin - FULL_RE_MIN) / (FULL_RE_MAX - FULL_RE_MIN) * MINIMAP_SIZE;
            const y2 = (viewReMax - FULL_RE_MIN) / (FULL_RE_MAX - FULL_RE_MIN) * MINIMAP_SIZE;

            const rectX = Math.max(0, Math.min(x1, x2));
            const rectY = Math.max(0, Math.min(y1, y2));
            const rectW = Math.min(MINIMAP_SIZE - rectX, Math.abs(x2 - x1));
            const rectH = Math.min(MINIMAP_SIZE - rectY, Math.abs(y2 - y1));

            // Draw viewport rectangle
            minimapCtx.strokeStyle = '#fff';
            minimapCtx.lineWidth = 2;
            minimapCtx.strokeRect(rectX, rectY, rectW, rectH);

            // Draw subtle fill
            minimapCtx.fillStyle = 'rgba(255,255,255,0.1)';
            minimapCtx.fillRect(rectX, rectY, rectW, rectH);
        }

        function renderMinimapProgressive() {
            const targetSamples = 200000;
            const samplesPerFrame = 5000;

            function frame() {
                if (minimapSamples < targetSamples) {
                    generateMinimapSamples(samplesPerFrame);
                    renderMinimap();
                    requestAnimationFrame(frame);
                } else {
                    minimapReady = true;
                    renderMinimap();
                }
            }
            frame();
        }

        // Click on minimap to navigate
        minimapCanvas.addEventListener('click', (e) => {
            const rect = minimapCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Convert to complex coordinates
            viewCenterIm = FULL_IM_MIN + (x / MINIMAP_SIZE) * (FULL_IM_MAX - FULL_IM_MIN);
            viewCenterRe = FULL_RE_MIN + (y / MINIMAP_SIZE) * (FULL_RE_MAX - FULL_RE_MIN);

            startRender();
        });

        minimapCanvas.style.cursor = 'crosshair';

        // Initialize minimap
        initMinimap();

        startRender();
    </script>
</body>
</html>
