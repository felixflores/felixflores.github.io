<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>üëÅÔ∏è Blinking Contest</title>
  <link rel="icon" type="image/x-icon" href="favicon.ico" />
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Courier New', monospace;
      background: #000;
      color: #00ff00;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }

    .container {
      text-align: center;
      max-width: 1200px;
      width: 100%;
      padding: 20px;
    }

    h1 {
      font-size: 48px;
      margin-bottom: 20px;
      text-shadow: 0 0 20px #00ff00;
    }

    .video-container {
      position: relative;
      display: inline-block;
      margin: 20px auto;
    }

    #video {
      width: 640px;
      height: 480px;
      border: 2px solid #00ff00;
      border-radius: 10px;
      transform: scaleX(-1);
    }

    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 640px;
      height: 480px;
      pointer-events: none;
      transform: scaleX(-1);
    }

    .debug-panel {
      background: rgba(0, 255, 0, 0.1);
      border: 1px solid #00ff00;
      border-radius: 10px;
      padding: 20px;
      margin: 20px auto;
      max-width: 600px;
      text-align: left;
    }

    .debug-item {
      margin: 10px 0;
      font-size: 14px;
    }

    .debug-label {
      color: #00ff00;
      font-weight: bold;
    }

    .debug-value {
      color: #00cc00;
      margin-left: 10px;
    }

    .eye-indicator {
      display: inline-block;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      margin-left: 10px;
      vertical-align: middle;
    }

    .eye-open {
      background: #00ff00;
      box-shadow: 0 0 10px #00ff00;
    }

    .eye-closed {
      background: #ff0000;
      box-shadow: 0 0 10px #ff0000;
    }

    button {
      background: #00ff00;
      color: #000;
      border: none;
      padding: 15px 30px;
      font-size: 18px;
      font-family: 'Courier New', monospace;
      cursor: pointer;
      border-radius: 5px;
      margin: 10px;
      transition: all 0.3s;
    }

    button:hover {
      background: #00cc00;
      transform: scale(1.05);
    }

    .loading {
      font-size: 24px;
      margin: 20px;
    }

    .back-link {
      position: absolute;
      top: 20px;
      left: 20px;
      color: #00ff00;
      text-decoration: none;
      font-size: 18px;
    }

    .back-link:hover {
      text-shadow: 0 0 10px #00ff00;
    }
  </style>
</head>
<body>
  <a href="index.html" class="back-link">‚Üê Back to Home</a>

  <div class="container">
    <h1>üëÅÔ∏è BLINKING CONTEST</h1>

    <div class="loading" id="loading">Loading face detection...</div>

    <div class="video-container" id="videoContainer" style="display: none;">
      <video id="video" autoplay playsinline></video>
      <canvas id="canvas"></canvas>
    </div>

    <div class="debug-panel" id="debugPanel" style="display: none;">
      <h3>üëÅÔ∏è Eye Tracking Debug</h3>
      <div class="debug-item">
        <span class="debug-label">Left Eye:</span>
        <span class="debug-value" id="leftEyePos">N/A</span>
        <span class="eye-indicator" id="leftEyeIndicator"></span>
      </div>
      <div class="debug-item">
        <span class="debug-label">Right Eye:</span>
        <span class="debug-value" id="rightEyePos">N/A</span>
        <span class="eye-indicator" id="rightEyeIndicator"></span>
      </div>
      <div class="debug-item">
        <span class="debug-label">Blink Detected:</span>
        <span class="debug-value" id="blinkStatus">NO</span>
      </div>
      <div class="debug-item">
        <span class="debug-label">Blink Count:</span>
        <span class="debug-value" id="blinkCount">0</span>
      </div>
    </div>

    <button id="startButton" style="display: none;">START TRACKING</button>
  </div>

  <script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const loading = document.getElementById('loading');
    const startButton = document.getElementById('startButton');
    const videoContainer = document.getElementById('videoContainer');
    const debugPanel = document.getElementById('debugPanel');

    let model = null;
    let isTracking = false;
    let blinkCount = 0;
    let lastBlinkTime = 0;

    // Eye state tracking
    let leftEyeOpen = true;
    let rightEyeOpen = true;
    let wasBlinking = false;

    // Eye landmark indices for FaceMesh
    const LEFT_EYE_INDICES = [33, 160, 158, 133, 153, 144];
    const RIGHT_EYE_INDICES = [362, 385, 387, 263, 373, 380];

    // EAR threshold for blink detection
    const EAR_THRESHOLD = 0.21;

    // Load FaceMesh model
    async function loadModel() {
      try {
        loading.textContent = 'Loading FaceMesh model...';
        console.log('Starting model load...');

        model = await faceLandmarksDetection.createDetector(
          faceLandmarksDetection.SupportedModels.MediaPipeFaceMesh,
          {
            runtime: 'mediapipe',
            solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh'
          }
        );

        console.log('Model loaded:', model);
        loading.textContent = 'Model loaded! Click START TRACKING';
        startButton.style.display = 'block';
      } catch (err) {
        loading.textContent = 'Error loading model: ' + err.message;
        console.error('Model load error:', err);
      }
    }

    // Start webcam
    async function startWebcam() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: 640,
            height: 480,
            facingMode: 'user'
          }
        });

        video.srcObject = stream;
        await video.play();

        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;

        videoContainer.style.display = 'block';
        debugPanel.style.display = 'block';
        startButton.style.display = 'none';
        loading.style.display = 'none';

        isTracking = true;
        detectFace();
      } catch (err) {
        loading.textContent = 'Error accessing camera: ' + err.message;
        console.error(err);
      }
    }

    // Calculate Euclidean distance between two points
    function distance(p1, p2) {
      return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
    }

    // Calculate Eye Aspect Ratio (EAR)
    function calculateEAR(eyeLandmarks) {
      // EAR = (||p2-p6|| + ||p3-p5||) / (2 * ||p1-p4||)
      const vertical1 = distance(eyeLandmarks[1], eyeLandmarks[5]);
      const vertical2 = distance(eyeLandmarks[2], eyeLandmarks[4]);
      const horizontal = distance(eyeLandmarks[0], eyeLandmarks[3]);

      return (vertical1 + vertical2) / (2.0 * horizontal);
    }

    // Get eye center from landmarks
    function getEyeCenter(eyeLandmarks) {
      const sumX = eyeLandmarks.reduce((sum, p) => sum + p.x, 0);
      const sumY = eyeLandmarks.reduce((sum, p) => sum + p.y, 0);
      return {
        x: sumX / eyeLandmarks.length,
        y: sumY / eyeLandmarks.length
      };
    }

    // Detect face and track eyes
    async function detectFace() {
      if (!isTracking) return;

      try {
        // Make sure video is ready
        if (video.readyState < 2) {
          requestAnimationFrame(detectFace);
          return;
        }

        const predictions = await model.estimateFaces(video);
        console.log('Predictions:', predictions.length);
        if (predictions.length > 0) {
          console.log('Face detected! Keypoints:', predictions[0].keypoints.length);
        }

        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (predictions.length > 0) {
          const face = predictions[0];
          const keypoints = face.keypoints;

        // Extract eye landmarks
        const leftEyeLandmarks = LEFT_EYE_INDICES.map(i => keypoints[i]);
        const rightEyeLandmarks = RIGHT_EYE_INDICES.map(i => keypoints[i]);

        // Calculate EAR for each eye
        const leftEAR = calculateEAR(leftEyeLandmarks);
        const rightEAR = calculateEAR(rightEyeLandmarks);

        // Get eye centers
        const leftEyeCenter = getEyeCenter(leftEyeLandmarks);
        const rightEyeCenter = getEyeCenter(rightEyeLandmarks);

        // Determine if eyes are open
        const leftEyeOpenNow = leftEAR > EAR_THRESHOLD;
        const rightEyeOpenNow = rightEAR > EAR_THRESHOLD;

        // Draw eye contours
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 2;

        // Left eye
        ctx.beginPath();
        leftEyeLandmarks.forEach((point, i) => {
          if (i === 0) ctx.moveTo(point.x, point.y);
          else ctx.lineTo(point.x, point.y);
        });
        ctx.closePath();
        ctx.stroke();

        // Right eye
        ctx.beginPath();
        rightEyeLandmarks.forEach((point, i) => {
          if (i === 0) ctx.moveTo(point.x, point.y);
          else ctx.lineTo(point.x, point.y);
        });
        ctx.closePath();
        ctx.stroke();

        // Draw eye centers
        ctx.fillStyle = leftEyeOpenNow ? '#00ff00' : '#ff0000';
        ctx.beginPath();
        ctx.arc(leftEyeCenter.x, leftEyeCenter.y, 5, 0, 2 * Math.PI);
        ctx.fill();

        ctx.fillStyle = rightEyeOpenNow ? '#00ff00' : '#ff0000';
        ctx.beginPath();
        ctx.arc(rightEyeCenter.x, rightEyeCenter.y, 5, 0, 2 * Math.PI);
        ctx.fill();

        // Update debug info
        document.getElementById('leftEyePos').textContent =
          `(${Math.round(leftEyeCenter.x)}, ${Math.round(leftEyeCenter.y)}) EAR: ${leftEAR.toFixed(3)}`;
        document.getElementById('rightEyePos').textContent =
          `(${Math.round(rightEyeCenter.x)}, ${Math.round(rightEyeCenter.y)}) EAR: ${rightEAR.toFixed(3)}`;

        // Update eye indicators
        const leftIndicator = document.getElementById('leftEyeIndicator');
        const rightIndicator = document.getElementById('rightEyeIndicator');

        leftIndicator.className = 'eye-indicator ' + (leftEyeOpenNow ? 'eye-open' : 'eye-closed');
        rightIndicator.className = 'eye-indicator ' + (rightEyeOpenNow ? 'eye-open' : 'eye-closed');

        // Detect blinks
        const bothEyesClosed = !leftEyeOpenNow && !rightEyeOpenNow;

        if (bothEyesClosed && !wasBlinking) {
          // Blink started
          const now = Date.now();
          if (now - lastBlinkTime > 300) { // Debounce (300ms between blinks)
            blinkCount++;
            lastBlinkTime = now;
            document.getElementById('blinkCount').textContent = blinkCount;
            document.getElementById('blinkStatus').textContent = 'YES!';

            // Flash the canvas
            ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
          }
          wasBlinking = true;
        } else if (!bothEyesClosed) {
          wasBlinking = false;
          document.getElementById('blinkStatus').textContent = 'NO';
        }
        } else {
          // No face detected - show debug message
          ctx.fillStyle = '#00ff00';
          ctx.font = '20px Courier New';
          ctx.fillText('No face detected', 10, 30);
        }
      } catch (err) {
        console.error('Detection error:', err);
        ctx.fillStyle = '#ff0000';
        ctx.font = '16px Courier New';
        ctx.fillText('Error: ' + err.message, 10, 30);
      }

      requestAnimationFrame(detectFace);
    }

    // Event listeners
    startButton.addEventListener('click', startWebcam);

    // Initialize
    loadModel();
  </script>
</body>
</html>
