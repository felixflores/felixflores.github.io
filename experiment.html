<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TLog - Thought Space</title>
  <link rel="icon" type="image/webp" href="logo.webp" />
  <script type="module" src="https://esm.run/@mlc-ai/web-llm"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', system-ui, sans-serif;
      background: #0a0a0a;
      color: #e0e0e0;
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    header {
      margin-bottom: 40px;
      border-bottom: 1px solid #333;
      padding-bottom: 20px;
    }

    h1 {
      font-size: 32px;
      font-weight: 600;
      margin-bottom: 8px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .subtitle {
      color: #888;
      font-size: 14px;
    }

    .back-link {
      display: inline-block;
      margin-bottom: 20px;
      color: #667eea;
      text-decoration: none;
      font-size: 14px;
    }

    .back-link:hover {
      text-decoration: underline;
    }

    .question-container {
      max-width: 800px;
      margin: 60px auto;
    }

    .question-input {
      width: 100%;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 40px;
      color: #e0e0e0;
      font-size: 18px;
      font-family: inherit;
      resize: none;
      transition: border-color 0.2s ease;
    }

    .question-input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    .question-input::placeholder {
      color: #555;
    }

    .hint-text {
      text-align: center;
      color: #555;
      font-size: 13px;
      margin-top: -30px;
      margin-bottom: 40px;
    }

    button {
      padding: 12px 24px;
      background: #667eea;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    button:hover {
      background: #5568d3;
      transform: translateY(-1px);
    }

    button:disabled {
      background: #333;
      cursor: not-allowed;
      transform: none;
    }

    .loading-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #0a0a0a;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: opacity 0.5s ease;
    }

    .loading-container.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .loading-text {
      color: #667eea;
      font-size: 14px;
      text-align: center;
      max-width: 400px;
    }

    .main-content {
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    .main-content.visible {
      opacity: 1;
    }

    .response {
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
      line-height: 1.6;
    }

    /* Character fade-in with blur for thinking section */
    .char-fade {
      animation: charFadeIn 0.3s ease-out forwards;
      opacity: 0;
    }

    @keyframes charFadeIn {
      from {
        opacity: 0;
        filter: blur(4px);
        transform: translateY(4px);
      }
      to {
        opacity: 1;
        filter: blur(0);
        transform: translateY(0);
      }
    }

    /* Typing cursor effect while streaming */
    .response.streaming::after {
      content: '▊';
      color: #667eea;
      animation: blink 1s step-end infinite;
      margin-left: 2px;
    }

    @keyframes blink {
      50% { opacity: 0; }
    }

    .response strong {
      color: #e0e0e0;
      font-weight: 600;
    }

    .response em {
      color: #a0a0a0;
      font-style: italic;
    }

    .response code {
      background: rgba(102, 126, 234, 0.1);
      color: #667eea;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: monospace;
      font-size: 0.9em;
    }

    .response p {
      margin-bottom: 12px;
    }

    .response p:last-child {
      margin-bottom: 0;
    }

    .response h1, .response h2, .response h3, .response h4, .response h5, .response h6 {
      color: #e0e0e0;
      margin-top: 20px;
      margin-bottom: 12px;
      font-weight: 600;
    }

    .response h1 { font-size: 24px; }
    .response h2 { font-size: 20px; }
    .response h3 { font-size: 18px; }
    .response h4 { font-size: 16px; }

    .response ul, .response ol {
      margin-left: 24px;
      margin-bottom: 12px;
    }

    .response li {
      margin-bottom: 6px;
    }

    .response blockquote {
      border-left: 3px solid #667eea;
      padding-left: 16px;
      margin: 12px 0;
      color: #b0b0b0;
    }

    .response pre {
      background: rgba(102, 126, 234, 0.1);
      padding: 12px;
      border-radius: 6px;
      overflow-x: auto;
      margin-bottom: 12px;
    }

    .response pre code {
      background: none;
      padding: 0;
    }

    .response-label {
      font-size: 12px;
      color: #888;
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .thinking-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
      padding: 12px 16px;
      background: rgba(102, 126, 234, 0.1);
      border-left: 3px solid #667eea;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
    }

    .thinking-header:hover {
      background: rgba(102, 126, 234, 0.15);
    }

    .thinking-header-left {
      display: flex;
      align-items: center;
    }

    .chevron {
      width: 16px;
      height: 16px;
      transition: transform 0.3s ease;
      fill: #667eea;
    }

    .chevron.expanded {
      transform: rotate(180deg);
    }

    .thinking-content {
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 0;
      margin-bottom: 20px;
      max-height: 80px;
      overflow-y: auto;
      overflow-x: hidden;
      position: relative;
      transition: max-height 0.3s ease;
    }

    .thinking-content.expanded {
      max-height: 400px;
    }

    .thinking-scroll {
      padding: 16px;
      padding-bottom: 20px;
      line-height: 1.6;
      color: #b0b0b0;
      font-size: 13px;
    }

    .thinking-scroll strong {
      color: #e0e0e0;
      font-weight: 600;
    }

    .thinking-scroll em {
      color: #a0a0a0;
      font-style: italic;
    }

    .thinking-scroll code {
      background: rgba(102, 126, 234, 0.1);
      color: #667eea;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: monospace;
      font-size: 0.9em;
    }

    .thinking-content::-webkit-scrollbar {
      width: 6px;
    }

    .thinking-content::-webkit-scrollbar-track {
      background: #1a1a1a;
    }

    .thinking-content::-webkit-scrollbar-thumb {
      background: #333;
      border-radius: 3px;
    }

    .thinking-content::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 60px;
      background: linear-gradient(to bottom, #1a1a1a 0%, transparent 100%);
      pointer-events: none;
      z-index: 1;
    }

    #thinkingSection {
      margin-bottom: 20px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .results-container {
      max-width: 800px;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <!-- Loading Screen -->
  <div class="loading-container" id="loadingContainer">
    <div style="text-align: center;">
      <h2 style="color: #667eea; margin-bottom: 10px;">Loading AI Model...</h2>
      <div class="loading-text" id="loadingText">Initializing model...</div>
    </div>
    <button id="continueBtn" style="display: none; margin-top: 20px; padding: 15px 40px; background: #667eea; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer;">
      Continue to TLog
    </button>
  </div>

  <!-- Main Content -->
  <div class="container main-content" id="mainContent">
    <a href="index.html" class="back-link">← Back to Home</a>

    <header>
      <h1>TLog</h1>
      <p class="subtitle">Ask anything. Watch the model think.</p>
    </header>

    <tlog-interface></tlog-interface>
  </div>

  <!-- TLog Interface Component -->
  <script type="module">
    import * as webllm from "https://esm.run/@mlc-ai/web-llm";

    class TLogInterface extends HTMLElement {
      // Configuration constants
      static STREAMING_CONSTANTS = {
        FALLBACK_TOKEN_THRESHOLD: 5,      // Tokens to wait before fallback to direct answer
        MAX_TOKENS: 2000,                 // Maximum tokens per response
        CURSOR_LINGER_MS: 1000            // How long cursor stays after streaming ends
      };

      constructor() {
        super();
        this.engine = null;
        this._scrollAnimationFrame = null;
        this._scrollAnimating = false;
      }

      connectedCallback() {
        this.innerHTML = `
          <div class="question-container">
            <textarea
              id="questionInput"
              class="question-input"
              placeholder="What's on your mind?"
              rows="3"
            ></textarea>
            <div class="hint-text">Press Enter to explore</div>
          </div>

          <div class="results-container">
            <div id="thinkingSection" style="display: none;">
              <div class="thinking-header" id="thinkingHeader">
                <div class="thinking-header-left">
                  <svg width="16" height="16" viewBox="0 0 16 16" fill="none" style="display: inline-block; margin-right: 8px;">
                    <path d="M8 2a6 6 0 100 12A6 6 0 008 2zm0 11a5 5 0 110-10 5 5 0 010 10z" fill="#667eea"/>
                    <path d="M8 4.5v4l2.5 1.5" stroke="#667eea" stroke-width="1.5" stroke-linecap="round"/>
                  </svg>
                  <span style="color: #667eea; font-size: 14px; font-weight: 500;">Thinking...</span>
                </div>
                <svg class="chevron" id="chevron" viewBox="0 0 16 16">
                  <path d="M4 6l4 4 4-4" stroke="#667eea" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              </div>
              <div class="thinking-content" id="thinkingContent">
                <div id="thinkingText" class="thinking-scroll"></div>
              </div>
            </div>

            <div id="response" style="display: none;">
              <div class="response-label">Answer</div>
              <div id="responseText" class="response"></div>
            </div>
          </div>
        `;

        this.setupElements();
        this.setupEventListeners();
      }

      setupElements() {
        this.elements = {
          input: this.querySelector('#questionInput'),
          thinkingSection: this.querySelector('#thinkingSection'),
          thinkingHeader: this.querySelector('#thinkingHeader'),
          thinkingContent: this.querySelector('#thinkingContent'),
          thinkingText: this.querySelector('#thinkingText'),
          chevron: this.querySelector('#chevron'),
          response: this.querySelector('#response'),
          responseText: this.querySelector('#responseText')
        };
      }

      setupEventListeners() {
        // Toggle thinking section expand/collapse
        this.elements.thinkingHeader.addEventListener('click', () => {
          const isExpanded = this.elements.thinkingContent.classList.toggle('expanded');
          this.elements.chevron.classList.toggle('expanded', isExpanded);
        });

        // Handle Enter key to submit question
        this.elements.input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            this.askQuestion();
          }
        });
      }

      setEngine(engine) {
        this.engine = engine;
      }

      startSmoothScroll() {
        if (this._scrollAnimating) return;
        this._scrollAnimating = true;

        const scroll = () => {
          if (!this._scrollAnimating) return;

          // Don't auto-scroll when expanded
          if (!this.elements.thinkingContent.classList.contains('expanded')) {
            const container = this.elements.thinkingContent;
            const maxScroll = container.scrollHeight - container.clientHeight;

            // Continuous smooth scroll to bottom
            if (container.scrollTop < maxScroll) {
              container.scrollTop = Math.min(container.scrollTop + 1, maxScroll);
            }
          }

          this._scrollAnimationFrame = requestAnimationFrame(scroll);
        };

        this._scrollAnimationFrame = requestAnimationFrame(scroll);
      }

      stopSmoothScroll() {
        this._scrollAnimating = false;
        if (this._scrollAnimationFrame) {
          cancelAnimationFrame(this._scrollAnimationFrame);
          this._scrollAnimationFrame = null;
        }
      }

      /**
       * Creates a token bufferer that accumulates text and flushes on whitespace.
       * This ensures smooth word-by-word streaming instead of character-by-character.
       */
      createTokenBufferer() {
        let buffer = '';

        return {
          append(token) {
            buffer += token;
            const whitespaceIndex = buffer.search(/\s/);

            if (whitespaceIndex !== -1) {
              const toFlush = buffer.substring(0, whitespaceIndex + 1);
              buffer = buffer.substring(whitespaceIndex + 1);
              return toFlush;
            }

            return null;
          },

          flush() {
            const toFlush = buffer;
            buffer = '';
            return toFlush;
          }
        };
      }

      /**
       * Appends text to element as plain text
       */
      appendText(element, text) {
        element.textContent += text;

        if (element === this.elements.thinkingText && !this._scrollAnimating) {
          this.startSmoothScroll();
        }
      }

      /**
       * Streams text with character fade-in animation (for thinking section only)
       */
      streamToThinking(text) {
        for (const char of text) {
          const span = document.createElement('span');
          span.className = 'char-fade';
          span.textContent = char;
          this.elements.thinkingText.appendChild(span);
        }

        if (!this._scrollAnimating) {
          this.startSmoothScroll();
        }
      }

      /**
       * Processes a question through the AI model with streaming response.
       *
       * Flow:
       * 1. Detect format: THINKING/ANSWER or direct answer
       * 2. Stream thinking process (if present)
       * 3. Transition to answer section
       * 4. Stream answer with real-time character fade-in
       */
      async askQuestion() {
        const question = this.elements.input.value.trim();
        if (!question || !this.engine) return;

        this.elements.input.value = '';
        this.elements.input.disabled = true;

        // Reset UI state
        this.elements.thinkingSection.style.display = 'block';
        this.elements.thinkingText.innerHTML = '';
        this.elements.thinkingContent.scrollTop = 0;
        this.elements.thinkingContent.classList.remove('expanded');
        this.elements.chevron.classList.remove('expanded');
        this.elements.thinkingContent.classList.add('streaming');
        this.elements.response.style.display = 'none';
        this.stopSmoothScroll();

        try {
          const messages = [
            { role: "system", content: "You are a thoughtful AI blog writer. You MUST ALWAYS respond in this exact format, no exceptions:\n\nTHINKING:\n<Brief thought process - 2-3 sentences max. What are the key points? What structure makes sense?>\n\nANSWER:\n<Your blog post content here - MUST use markdown formatting with headings>\n\nCRITICAL RULES - NO EXCEPTIONS:\n1. ALWAYS start with \"THINKING:\" then \"ANSWER:\" - even for simple questions\n2. Your ANSWER section MUST be a properly formatted blog post with ## headings\n3. NEVER write plain paragraphs without structure - ALWAYS include ## headings to organize ideas\n\nYour ANSWER must include:\n- An engaging opening paragraph (no heading needed for intro)\n- ## Section Heading for each major idea (REQUIRED - at least 2-3 headings)\n- Blank lines (\\n\\n) between paragraphs\n- **bold** for key terms\n- Bullet points (-) when listing items\n- Conversational, storytelling tone\n- 3-5+ paragraphs total\n- A conclusion section\n\nEXAMPLE FORMAT:\nANSWER:\nOpening paragraph that hooks the reader...\n\n## First Major Point\nParagraph exploring this idea...\n\n## Second Major Point  \nParagraph exploring this idea...\n\n## Conclusion\nWrapping up thoughts...\n\nRemember: Every answer MUST have ## headings. No plain paragraph responses." },
            { role: "user", content: question }
          ];

          const completion = await this.engine.chat.completions.create({
            messages: messages,
            temperature: 0.7,
            max_tokens: TLogInterface.STREAMING_CONSTANTS.MAX_TOKENS,
            stream: true,
          });

          const bufferer = this.createTokenBufferer();

          // State machine: initial -> thinking -> answer (or initial -> answer if no THINKING)
          let mode = 'initial';
          let fullBuffer = '';
          let tokenCount = 0;
          let answerAccumulator = ''; // Accumulate full answer for markdown rendering

          for await (const chunk of completion) {
            const token = chunk.choices[0]?.delta?.content || '';
            if (!token) continue;

            tokenCount++;
            const tempBuffer = fullBuffer + token;

            // Initial mode: detect whether model is using THINKING/ANSWER format
            if (mode === 'initial') {
              if (tempBuffer.includes('THINKING:')) {
                // Model is using structured format - enter thinking mode
                mode = 'thinking';
                fullBuffer = tempBuffer;
                bufferer.flush();

                const afterThinking = fullBuffer.split('THINKING:')[1] || '';
                for (const char of afterThinking) {
                  const flushed = bufferer.append(char);
                  if (flushed) this.streamToThinking(flushed);
                }

                fullBuffer = '';
                continue;

              } else if (tokenCount > TLogInterface.STREAMING_CONSTANTS.FALLBACK_TOKEN_THRESHOLD) {
                // Fallback: model didn't use THINKING format, stream as answer
                mode = 'answer';
                answerAccumulator = tempBuffer;

                this.elements.response.style.display = 'block';
                this.elements.response.classList.add('streaming');
                try {
                  const html = marked.parse(answerAccumulator);
                  this.elements.responseText.innerHTML = html;
                } catch (e) {
                  this.elements.responseText.textContent = answerAccumulator;
                }

                fullBuffer = '';
                continue;
              }
            }

            // Thinking to Answer transition
            if (mode === 'thinking' && tempBuffer.includes('ANSWER:')) {
              mode = 'answer';
              fullBuffer = tempBuffer;
              bufferer.flush();

              const afterAnswer = fullBuffer.split('ANSWER:')[1] || '';
              // Use raw response without any manipulation
              answerAccumulator = afterAnswer;

              // Update thinking section UI
              this.elements.thinkingHeader.querySelector('span').textContent = 'Thought Process';
              this.elements.thinkingContent.classList.remove('streaming');
              this.stopSmoothScroll();

              // Show answer section and stream initial content
              this.elements.response.style.display = 'block';
              this.elements.response.classList.add('streaming');
              this.elements.responseText.innerHTML = '';
              if (answerAccumulator) {
                try {
                  const html = marked.parse(answerAccumulator);
                  this.elements.responseText.innerHTML = html;
                } catch (e) {
                  this.elements.responseText.textContent = answerAccumulator;
                }
              }

              fullBuffer = '';
              continue;
            }

            // Normal streaming: process token through bufferer for both thinking and answer
            if (mode !== 'initial') {
              const flushed = bufferer.append(token);
              if (flushed) {
                if (mode === 'thinking') {
                  this.streamToThinking(flushed);
                } else if (mode === 'answer') {
                  // Accumulate and continuously parse markdown
                  answerAccumulator += flushed;
                  try {
                    const html = marked.parse(answerAccumulator);
                    this.elements.responseText.innerHTML = html;
                  } catch (e) {
                    this.elements.responseText.textContent = answerAccumulator;
                  }
                }
              }
            }

            fullBuffer = tempBuffer;
          }

          // Flush any remaining buffer
          const remaining = bufferer.flush();
          if (remaining && mode !== 'initial') {
            if (mode === 'thinking') {
              this.streamToThinking(remaining);
            } else if (mode === 'answer') {
              answerAccumulator += remaining;
              try {
                const html = marked.parse(answerAccumulator);
                this.elements.responseText.innerHTML = html;
              } catch (e) {
                this.elements.responseText.textContent = answerAccumulator;
              }
            }
          }

          // Remove streaming cursor after brief linger
          setTimeout(() => {
            this.elements.response.classList.remove('streaming');
          }, TLogInterface.STREAMING_CONSTANTS.CURSOR_LINGER_MS);

        } catch (error) {
          this.elements.thinkingSection.style.display = 'none';
          this.elements.response.style.display = 'block';
          this.elements.responseText.textContent = 'Error: ' + error.message;
          console.error(error);
        }

        // Re-enable input
        this.elements.input.disabled = false;
        this.elements.input.focus();
      }
    }

    customElements.define('tlog-interface', TLogInterface);

    // Initialize the app
    const loadingContainer = document.getElementById('loadingContainer');
    const loadingText = document.getElementById('loadingText');
    const mainContent = document.getElementById('mainContent');
    const continueBtn = document.getElementById('continueBtn');

    async function initModels() {
      try {
        loadingText.textContent = 'Loading Qwen2.5-1.5B reasoning model...';

        const engine = await webllm.CreateMLCEngine(
          "Qwen2.5-1.5B-Instruct-q4f16_1-MLC",
          {
            initProgressCallback: (info) => {
              loadingText.textContent = info.text || 'Loading...';
            }
          }
        );

        // Show continue button
        loadingText.textContent = 'Model ready!';
        continueBtn.style.display = 'block';

        // Setup continue button
        continueBtn.addEventListener('click', () => {
          loadingContainer.classList.add('hidden');
          mainContent.classList.add('visible');

          // Set the engine on the TLog interface
          const tlogInterface = document.querySelector('tlog-interface');
          tlogInterface.setEngine(engine);

          setTimeout(() => {
            const input = document.querySelector('#questionInput');
            if (input) input.focus();
          }, 500);
        });
      } catch (error) {
        loadingText.textContent = 'Error loading model: ' + error.message;
        console.error(error);
      }
    }

    initModels();
  </script>
</body>
</html>
