<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TLog - Thought Space</title>
  <script type="module" src="https://esm.run/@mlc-ai/web-llm"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', system-ui, sans-serif;
      background: #0a0a0a;
      color: #e0e0e0;
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    header {
      margin-bottom: 40px;
      border-bottom: 1px solid #333;
      padding-bottom: 20px;
    }

    h1 {
      font-size: 32px;
      font-weight: 600;
      margin-bottom: 8px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .subtitle {
      color: #888;
      font-size: 14px;
    }

    .back-link {
      display: inline-block;
      margin-bottom: 20px;
      color: #667eea;
      text-decoration: none;
      font-size: 14px;
    }

    .back-link:hover {
      text-decoration: underline;
    }

    .question-container {
      max-width: 800px;
      margin: 60px auto;
    }

    .question-input {
      width: 100%;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 40px;
      color: #e0e0e0;
      font-size: 18px;
      font-family: inherit;
      resize: none;
      transition: border-color 0.2s ease;
    }

    .question-input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    .question-input::placeholder {
      color: #555;
    }

    .hint-text {
      text-align: center;
      color: #555;
      font-size: 13px;
      margin-top: -30px;
      margin-bottom: 40px;
    }

    button {
      padding: 12px 24px;
      background: #667eea;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    button:hover {
      background: #5568d3;
      transform: translateY(-1px);
    }

    button:disabled {
      background: #333;
      cursor: not-allowed;
      transform: none;
    }

    .loading-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #0a0a0a;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: opacity 0.5s ease;
    }

    .loading-container.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .loading-text {
      color: #667eea;
      font-size: 14px;
      text-align: center;
      max-width: 400px;
    }

    .main-content {
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    .main-content.visible {
      opacity: 1;
    }

    .response {
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
      line-height: 1.6;
    }

    /* Character-by-character reveal effect */
    .char-reveal {
      display: inline;
      animation: charReveal 0.6s ease-out forwards;
    }

    @keyframes charReveal {
      from {
        opacity: 0;
        filter: blur(6px);
        transform: translateY(8px);
      }
      to {
        opacity: 1;
        filter: blur(0);
        transform: translateY(0);
      }
    }

    /* Typing cursor effect while streaming */
    .response.streaming::after {
      content: '‚ñä';
      color: #667eea;
      animation: blink 1s step-end infinite;
      margin-left: 2px;
    }

    @keyframes blink {
      50% { opacity: 0; }
    }

    .response strong {
      color: #e0e0e0;
      font-weight: 600;
    }

    .response em {
      color: #a0a0a0;
      font-style: italic;
    }

    .response code {
      background: rgba(102, 126, 234, 0.1);
      color: #667eea;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: monospace;
      font-size: 0.9em;
    }

    .response p {
      margin-bottom: 12px;
    }

    .response p:last-child {
      margin-bottom: 0;
    }

    .response-label {
      font-size: 12px;
      color: #888;
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .char-fade {
      animation: charFadeIn 0.2s ease-in forwards;
      opacity: 0;
    }

    @keyframes charFadeIn {
      from {
        opacity: 0;
        transform: translateY(2px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .thinking-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
      padding: 12px 16px;
      background: rgba(102, 126, 234, 0.1);
      border-left: 3px solid #667eea;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
    }

    .thinking-header:hover {
      background: rgba(102, 126, 234, 0.15);
    }

    .thinking-header-left {
      display: flex;
      align-items: center;
    }

    .chevron {
      width: 16px;
      height: 16px;
      transition: transform 0.3s ease;
      fill: #667eea;
    }

    .chevron.expanded {
      transform: rotate(180deg);
    }

    .thinking-content {
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 0;
      margin-bottom: 20px;
      max-height: 80px;
      overflow-y: auto;
      overflow-x: hidden;
      position: relative;
      transition: max-height 0.3s ease;
    }

    .thinking-content.expanded {
      max-height: 400px;
    }

    .thinking-scroll {
      padding: 16px;
      padding-bottom: 20px;
      line-height: 1.6;
      color: #b0b0b0;
      font-size: 13px;
    }

    .thinking-scroll strong {
      color: #e0e0e0;
      font-weight: 600;
    }

    .thinking-scroll em {
      color: #a0a0a0;
      font-style: italic;
    }

    .thinking-scroll code {
      background: rgba(102, 126, 234, 0.1);
      color: #667eea;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: monospace;
      font-size: 0.9em;
    }

    .thinking-content::-webkit-scrollbar {
      width: 6px;
    }

    .thinking-content::-webkit-scrollbar-track {
      background: #1a1a1a;
    }

    .thinking-content::-webkit-scrollbar-thumb {
      background: #333;
      border-radius: 3px;
    }

    .thinking-content::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 60px;
      background: linear-gradient(to bottom, #1a1a1a 0%, transparent 100%);
      pointer-events: none;
      z-index: 1;
    }

    #thinkingSection {
      margin-bottom: 20px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .results-container {
      max-width: 800px;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <!-- Loading Screen -->
  <div class="loading-container" id="loadingContainer">
    <div style="text-align: center; margin-bottom: 20px;">
      <h2 style="color: #667eea; margin-bottom: 10px;">Loading AI Model...</h2>
      <div class="loading-text" id="loadingText">Initializing model...</div>
      <div style="margin-top: 10px; color: #888; font-size: 12px;">Play while you wait ‚¨áÔ∏è</div>
    </div>
    <asteroids-game id="loadingGame"></asteroids-game>
    <div style="margin-top: 15px; color: #888; font-size: 13px; text-align: center;">
      Arrow keys to rotate/thrust ‚Ä¢ Space to shoot
    </div>
    <button id="continueBtn" style="display: none; margin-top: 20px; padding: 15px 40px; background: #667eea; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer;">
      Continue to TLog
    </button>
  </div>

  <!-- Main Content -->
  <div class="container main-content" id="mainContent">
    <a href="index.html" class="back-link">‚Üê Back to Home</a>

    <header>
      <h1>TLog</h1>
      <p class="subtitle">Ask anything. Watch the model think.</p>
    </header>

    <tlog-interface></tlog-interface>
  </div>

  <!-- Asteroids Game Component -->
  <script>
    class AsteroidsGame extends HTMLElement {
      constructor() {
        super();
        this.canvas = null;
        this.ctx = null;
        this.gameState = null;
        this.keyHandlers = null;
        this.animationId = null;
      }

      connectedCallback() {
        this.innerHTML = `
          <canvas width="640" height="480" style="border: 2px solid #667eea; background: #000;"></canvas>
        `;
        this.canvas = this.querySelector('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.initGame();
        this.startGameLoop();
      }

      disconnectedCallback() {
        this.cleanup();
      }

      cleanup() {
        if (this.keyHandlers) {
          window.removeEventListener('keydown', this.keyHandlers.down);
          window.removeEventListener('keyup', this.keyHandlers.up);
        }
        if (this.animationId) {
          cancelAnimationFrame(this.animationId);
        }
      }

      initGame() {
        const w = this.canvas.width;
        const h = this.canvas.height;

        this.gameState = {
          w, h,
          ship: { x: w/2, y: h/2, vx: 0, vy: 0, angle: -Math.PI/2, thrustPower: 0 },
          keys: {},
          bullets: [],
          asteroids: [],
          score: 0,
          gameOver: false,
          collected: {},
          emojiTypes: ['üóø', 'üí©', 'üåÆ', 'üçï', 'üßÄ', 'ü•ë', 'üçÜ', 'üå∂Ô∏è', 'üßá', 'ü•ì']
        };

        // Setup input handlers
        this.keyHandlers = {
          down: (e) => {
            this.gameState.keys[e.key] = true;
            if (e.key === ' ') {
              e.preventDefault();
              if (this.gameState.gameOver) {
                this.restartGame();
              } else {
                this.shoot();
              }
            }
          },
          up: (e) => this.gameState.keys[e.key] = false
        };

        window.addEventListener('keydown', this.keyHandlers.down);
        window.addEventListener('keyup', this.keyHandlers.up);

        // Spawn initial asteroids
        for (let i = 0; i < 4; i++) this.spawnAsteroid();
      }

      restartGame() {
        const { w, h } = this.gameState;
        this.gameState.ship = { x: w/2, y: h/2, vx: 0, vy: 0, angle: -Math.PI/2, thrustPower: 0 };
        this.gameState.bullets = [];
        this.gameState.asteroids = [];
        this.gameState.score = 0;
        this.gameState.gameOver = false;
        this.gameState.collected = {};
        for (let i = 0; i < 4; i++) this.spawnAsteroid();
      }

      spawnAsteroid(x, y, size = 3, emoji = null) {
        const { w, h, emojiTypes, asteroids } = this.gameState;
        const speed = (4 - size) * 0.5;
        const numPoints = 8 + Math.floor(Math.random() * 4);
        const vertices = [];

        for (let i = 0; i < numPoints; i++) {
          const angle = (i / numPoints) * Math.PI * 2;
          const radius = 0.7 + Math.random() * 0.5;
          vertices.push({ angle, radius });
        }

        asteroids.push({
          x: x || Math.random() * w,
          y: y || Math.random() * h,
          vx: (Math.random() - 0.5) * speed,
          vy: (Math.random() - 0.5) * speed,
          size: size,
          angle: Math.random() * Math.PI * 2,
          spin: (Math.random() - 0.5) * 0.05,
          vertices: vertices,
          emoji: emoji || emojiTypes[Math.floor(Math.random() * emojiTypes.length)]
        });
      }

      shoot() {
        if (this.gameState.gameOver) return;
        const { ship, bullets } = this.gameState;
        bullets.push({
          x: ship.x + Math.cos(ship.angle) * 10,
          y: ship.y + Math.sin(ship.angle) * 10,
          vx: Math.cos(ship.angle) * 5,
          vy: Math.sin(ship.angle) * 5,
          life: 60
        });
      }

      update() {
        const { ship, keys, bullets, asteroids, w, h } = this.gameState;
        if (this.gameState.gameOver) return;

        // Ship rotation
        if (keys['ArrowLeft']) ship.angle -= 0.08;
        if (keys['ArrowRight']) ship.angle += 0.08;

        // Smooth thrust
        if (keys['ArrowUp']) {
          ship.thrustPower = Math.min(ship.thrustPower + 0.008, 1);
        } else {
          ship.thrustPower = Math.max(ship.thrustPower - 0.03, 0);
        }

        // Apply thrust
        if (ship.thrustPower > 0) {
          const thrust = ship.thrustPower * 0.15;
          ship.vx += Math.cos(ship.angle) * thrust;
          ship.vy += Math.sin(ship.angle) * thrust;
        }

        // Friction
        ship.vx *= 0.99;
        ship.vy *= 0.99;

        // Move ship
        ship.x += ship.vx;
        ship.y += ship.vy;

        // Wrap ship
        if (ship.x < 0) ship.x = w;
        if (ship.x > w) ship.x = 0;
        if (ship.y < 0) ship.y = h;
        if (ship.y > h) ship.y = 0;

        // Update bullets
        this.gameState.bullets = bullets.filter(b => {
          b.x += b.vx;
          b.y += b.vy;
          b.life--;
          return b.life > 0 && b.x > 0 && b.x < w && b.y > 0 && b.y < h;
        });

        // Update asteroids
        asteroids.forEach(a => {
          a.x += a.vx;
          a.y += a.vy;
          a.angle += a.spin;
          if (a.x < 0) a.x = w;
          if (a.x > w) a.x = 0;
          if (a.y < 0) a.y = h;
          if (a.y > h) a.y = 0;

          // Check collision with ship
          if (!a.collectable) {
            const dx = ship.x - a.x;
            const dy = ship.y - a.y;
            if (Math.sqrt(dx*dx + dy*dy) < a.size * 10) {
              this.gameState.gameOver = true;
            }
          }
        });

        // Check bullet collisions
        bullets.forEach((b, bi) => {
          asteroids.forEach((a, ai) => {
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            if (Math.sqrt(dx*dx + dy*dy) < a.size * 10) {
              bullets.splice(bi, 1);

              if (a.size <= 2) {
                a.collectable = true;
                a.vx *= 0.5;
                a.vy *= 0.5;
                this.gameState.score += (4 - a.size) * 10;
              } else {
                asteroids.splice(ai, 1);
                this.gameState.score += (4 - a.size) * 10;
                this.spawnAsteroid(a.x, a.y, a.size - 1, a.emoji);
                this.spawnAsteroid(a.x, a.y, a.size - 1, a.emoji);
              }

              const hasNonCollectables = asteroids.some(ast => !ast.collectable);
              if (!hasNonCollectables) {
                for (let i = 0; i < 4; i++) this.spawnAsteroid();
              }
            }
          });
        });

        // Check ship collision with collectables
        asteroids.forEach((a, ai) => {
          if (a.collectable) {
            const dx = ship.x - a.x;
            const dy = ship.y - a.y;
            if (Math.sqrt(dx*dx + dy*dy) < 15) {
              asteroids.splice(ai, 1);
              this.gameState.score += 50;
              if (!this.gameState.collected[a.emoji]) {
                this.gameState.collected[a.emoji] = 0;
              }
              this.gameState.collected[a.emoji]++;
            }
          }
        });
      }

      render() {
        const { w, h, ship, bullets, asteroids, score, collected, gameOver } = this.gameState;
        const ctx = this.ctx;

        // Clear
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, w, h);

        // Draw ship
        ctx.save();
        ctx.translate(ship.x, ship.y);
        ctx.rotate(ship.angle);
        ctx.strokeStyle = '#667eea';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(10, 0);
        ctx.lineTo(-8, -6);
        ctx.lineTo(-5, 0);
        ctx.lineTo(-8, 6);
        ctx.closePath();
        ctx.stroke();

        // Thrust flame
        if (ship.thrustPower > 0 && !gameOver) {
          const flameLength = 7 + ship.thrustPower * 5;
          ctx.fillStyle = `rgba(255, 107, 107, ${ship.thrustPower})`;
          ctx.beginPath();
          ctx.moveTo(-5, 0);
          ctx.lineTo(-5 - flameLength, -3);
          ctx.lineTo(-5 - flameLength, 3);
          ctx.closePath();
          ctx.fill();
        }
        ctx.restore();

        // Draw bullets
        ctx.fillStyle = '#fff';
        bullets.forEach(b => {
          ctx.fillRect(b.x - 1, b.y - 1, 2, 2);
        });

        // Draw asteroids
        asteroids.forEach(a => {
          ctx.save();
          ctx.translate(a.x, a.y);
          ctx.rotate(a.angle);

          if (!a.collectable) {
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 2;
            ctx.beginPath();
            const r = a.size * 10;
            a.vertices.forEach((v, i) => {
              const x = Math.cos(v.angle) * r * v.radius;
              const y = Math.sin(v.angle) * r * v.radius;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            });
            ctx.closePath();
            ctx.stroke();
          }

          const size = a.collectable ? 20 : a.size * 15;
          ctx.font = `${size}px Arial`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(a.emoji, 0, 0);

          if (a.collectable) {
            ctx.shadowColor = '#ffff00';
            ctx.shadowBlur = 15;
            ctx.fillText(a.emoji, 0, 0);
            ctx.shadowBlur = 0;
          }

          ctx.restore();
        });

        // Score
        ctx.fillStyle = '#667eea';
        ctx.font = '16px monospace';
        ctx.fillText(`SCORE: ${score}`, 10, 25);

        // Collected emojis
        let yOffset = 50;
        Object.keys(collected).forEach(emoji => {
          ctx.fillStyle = '#fff';
          ctx.font = '18px Arial';
          ctx.fillText(`${emoji} x${collected[emoji]}`, 10, yOffset);
          yOffset += 25;
        });

        if (gameOver) {
          const messages = [
            'Destroyed by a üåÆ',
            'RIP Space Captain',
            'You got memed',
            'The üí© got you',
            'Git gud',
            'Skill issue detected'
          ];
          const msg = messages[Math.floor(Math.random() * messages.length)];

          ctx.fillStyle = '#ff6b6b';
          ctx.font = 'bold 32px monospace';
          ctx.textAlign = 'center';
          ctx.fillText('GAME OVER', w/2, h/2 - 20);
          ctx.font = '18px monospace';
          ctx.fillText(msg, w/2, h/2 + 15);
          ctx.font = '14px monospace';
          ctx.fillStyle = '#667eea';
          ctx.fillText('Press SPACE to restart', w/2, h/2 + 45);
          ctx.textAlign = 'left';
        }
      }

      startGameLoop() {
        const loop = () => {
          this.update();
          this.render();
          this.animationId = requestAnimationFrame(loop);
        };
        loop();
      }
    }

    customElements.define('asteroids-game', AsteroidsGame);
  </script>

  <!-- TLog Interface Component -->
  <script type="module">
    import * as webllm from "https://esm.run/@mlc-ai/web-llm";

    class TLogInterface extends HTMLElement {
      constructor() {
        super();
        this.engine = null;
        this.scrollAnimationFrame = null;
        this.isScrolling = false;
      }

      connectedCallback() {
        this.innerHTML = `
          <div class="question-container">
            <textarea
              id="questionInput"
              class="question-input"
              placeholder="What's on your mind?"
              rows="3"
            ></textarea>
            <div class="hint-text">Press Enter to explore</div>
          </div>

          <div class="results-container">
            <div id="thinkingSection" style="display: none;">
              <div class="thinking-header" id="thinkingHeader">
                <div class="thinking-header-left">
                  <svg width="16" height="16" viewBox="0 0 16 16" fill="none" style="display: inline-block; margin-right: 8px;">
                    <path d="M8 2a6 6 0 100 12A6 6 0 008 2zm0 11a5 5 0 110-10 5 5 0 010 10z" fill="#667eea"/>
                    <path d="M8 4.5v4l2.5 1.5" stroke="#667eea" stroke-width="1.5" stroke-linecap="round"/>
                  </svg>
                  <span style="color: #667eea; font-size: 14px; font-weight: 500;">Thinking...</span>
                </div>
                <svg class="chevron" id="chevron" viewBox="0 0 16 16">
                  <path d="M4 6l4 4 4-4" stroke="#667eea" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              </div>
              <div class="thinking-content" id="thinkingContent">
                <div id="thinkingText" class="thinking-scroll"></div>
              </div>
            </div>

            <div id="response" style="display: none;">
              <div class="response-label">Answer</div>
              <div id="responseText" class="response"></div>
            </div>
          </div>
        `;

        this.setupElements();
        this.setupEventListeners();
      }

      setupElements() {
        this.elements = {
          input: this.querySelector('#questionInput'),
          thinkingSection: this.querySelector('#thinkingSection'),
          thinkingHeader: this.querySelector('#thinkingHeader'),
          thinkingContent: this.querySelector('#thinkingContent'),
          thinkingText: this.querySelector('#thinkingText'),
          chevron: this.querySelector('#chevron'),
          response: this.querySelector('#response'),
          responseText: this.querySelector('#responseText')
        };
      }

      setupEventListeners() {
        // Toggle thinking section expand/collapse
        this.elements.thinkingHeader.addEventListener('click', () => {
          const isExpanded = this.elements.thinkingContent.classList.toggle('expanded');
          this.elements.chevron.classList.toggle('expanded', isExpanded);
        });

        // Handle Enter key to submit question
        this.elements.input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            this.askQuestion();
          }
        });
      }

      setEngine(engine) {
        this.engine = engine;
      }

      startSmoothScroll() {
        if (this._scrollAnimating) return;
        this._scrollAnimating = true;

        const scroll = () => {
          if (!this._scrollAnimating) return;

          // Don't auto-scroll when expanded
          if (!this.elements.thinkingContent.classList.contains('expanded')) {
            const container = this.elements.thinkingContent;
            const maxScroll = container.scrollHeight - container.clientHeight;

            // Continuous smooth scroll to bottom
            if (container.scrollTop < maxScroll) {
              container.scrollTop = Math.min(container.scrollTop + 1, maxScroll);
            }
          }

          this._scrollAnimationFrame = requestAnimationFrame(scroll);
        };

        this._scrollAnimationFrame = requestAnimationFrame(scroll);
      }

      stopSmoothScroll() {
        this._scrollAnimating = false;
        if (this._scrollAnimationFrame) {
          cancelAnimationFrame(this._scrollAnimationFrame);
          this._scrollAnimationFrame = null;
        }
      }

      // Token bufferer class - accumulates tokens and flushes on whitespace
      createTokenBufferer() {
        let buffer = '';
        let hasSeenNonWhitespace = false;

        return {
          append(token) {
            buffer += token;

            // Check if we have whitespace to flush on
            const whitespaceIndex = buffer.search(/\s/);
            if (whitespaceIndex !== -1) {
              // Flush up to and including the first whitespace
              const toFlush = buffer.substring(0, whitespaceIndex + 1);
              buffer = buffer.substring(whitespaceIndex + 1);
              return toFlush;
            }

            return null; // Nothing to flush yet
          },

          flush() {
            const toFlush = buffer;
            buffer = '';
            return toFlush;
          },

          peek() {
            return buffer;
          }
        };
      }

      // Stream text component - handles character fade-in animations
      streamToComponent(element, text) {
        // Append characters immediately (real-time)
        for (const char of text) {
          const span = document.createElement('span');
          span.className = 'char-reveal';
          span.textContent = char;
          element.appendChild(span);

          // Start smooth scrolling for thinking text
          if (element === this.elements.thinkingText && !this._scrollAnimating) {
            this.startSmoothScroll();
          }
        }
      }

      async askQuestion() {
        const question = this.elements.input.value.trim();
        if (!question || !this.engine) return;

        // Clear input and disable while processing
        this.elements.input.value = '';
        this.elements.input.disabled = true;

        // Reset UI
        this.elements.thinkingSection.style.display = 'block';
        this.elements.thinkingText.innerHTML = '';
        this.elements.thinkingContent.scrollTop = 0;
        this.elements.thinkingContent.classList.remove('expanded');
        this.elements.chevron.classList.remove('expanded');
        this.elements.thinkingContent.classList.add('streaming');
        this.elements.response.style.display = 'none';
        this.stopSmoothScroll();

        try {
          const messages = [
            { role: "system", content: "You are a reasoning AI. You MUST structure your response in exactly this format:\n\nTHINKING:\n- First point of reasoning\n- Second point of reasoning\n- Third point of reasoning\n(add more bullet points as needed)\n\nANSWER:\nYour final answer here\n\nNEVER skip the THINKING section. Always show your reasoning with bullet points before giving the ANSWER." },
            { role: "user", content: question }
          ];

          const completion = await this.engine.chat.completions.create({
            messages: messages,
            temperature: 0.7,
            max_tokens: 600,
            stream: true,
          });

          const bufferer = this.createTokenBufferer();
          let mode = 'initial'; // 'initial', 'thinking', 'answer'
          let fullBuffer = ''; // Track everything for mode detection
          let tokenCount = 0;

          // Token velocity tracking
          let lastTokenTime = Date.now();
          let tokenTimings = [];

          for await (const chunk of completion) {
            const token = chunk.choices[0]?.delta?.content || '';
            if (!token) continue;

            console.log('[RAW TOKEN]', JSON.stringify(token));
            tokenCount++;

            // Track token velocity for dynamic char delay
            const now = Date.now();
            tokenTimings.push(now - lastTokenTime);
            if (tokenTimings.length > 5) tokenTimings.shift();
            lastTokenTime = now;

            const avgTokenTime = tokenTimings.reduce((a, b) => a + b, 0) / tokenTimings.length;
            this._currentCharDelay = Math.max(0.0005, Math.min(0.005, avgTokenTime / 1000 / 30));

            // Check for mode transitions BEFORE adding to fullBuffer/bufferer
            const tempBuffer = fullBuffer + token;

            // Mode detection using tempBuffer
            if (mode === 'initial') {
              // Check if response starts with THINKING
              if (tempBuffer.includes('THINKING:')) {
                mode = 'thinking';
                fullBuffer = tempBuffer;

                // Clear the bufferer to remove any partial "THINKING:" text
                bufferer.flush();

                const afterThinking = fullBuffer.split('THINKING:')[1] || '';

                // Feed the text after THINKING: into the bufferer
                for (const char of afterThinking) {
                  const flushed = bufferer.append(char);
                  if (flushed) {
                    this.streamToComponent(this.elements.thinkingText, flushed);
                  }
                }

                fullBuffer = ''; // Clear fullBuffer since we've processed it
                console.log('[MODE] Thinking');
                continue; // Skip the rest of this iteration
              } else if (tokenCount > 5) {
                // Fallback: if no THINKING after several tokens, go straight to answer
                mode = 'answer';
                fullBuffer = tempBuffer;

                // Clear the bufferer to ensure no stale content
                bufferer.flush();

                this.elements.response.style.display = 'block';
                this.elements.response.classList.add('streaming');
                this.elements.responseText.innerHTML = '';

                // Feed accumulated fullBuffer into the bufferer
                for (const char of fullBuffer) {
                  const flushed = bufferer.append(char);
                  if (flushed) {
                    this.streamToComponent(this.elements.responseText, flushed);
                  }
                }

                fullBuffer = ''; // Clear fullBuffer
                console.log('[MODE] Answer (no thinking)');
                continue; // Skip the rest of this iteration
              }
            }

            // Check for mode switch from thinking to answer
            if (mode === 'thinking' && tempBuffer.includes('ANSWER:')) {
              mode = 'answer';
              fullBuffer = tempBuffer;

              // Clear the bufferer to remove any partial "ANSWER:" text
              bufferer.flush();

              const afterAnswer = fullBuffer.split('ANSWER:')[1] || '';
              const cleanedAfterAnswer = afterAnswer.replace(/^[\s:.\-]+/, ''); // Clean leading punctuation

              this.elements.thinkingHeader.querySelector('span').textContent = 'Thought Process';
              this.elements.thinkingContent.classList.remove('streaming');
              this.stopSmoothScroll();

              // Show answer section immediately (no delay to avoid losing tokens)
              this.elements.response.style.display = 'block';
              this.elements.response.classList.add('streaming');
              this.elements.responseText.innerHTML = '';

              // Feed the text after ANSWER: into the bufferer by simulating tokens
              for (const char of cleanedAfterAnswer) {
                const flushed = bufferer.append(char);
                if (flushed) {
                  this.streamToComponent(this.elements.responseText, flushed);
                }
              }

              fullBuffer = ''; // Clear fullBuffer since we've processed it
              console.log('[MODE] Answer');
              continue; // Skip the rest of this iteration since we've already processed
            }

            // Normal token processing - only if not in initial mode
            if (mode !== 'initial') {
              // Append token to bufferer
              const flushed = bufferer.append(token);

              if (flushed) {
                // Stream flushed text to appropriate component
                if (mode === 'thinking') {
                  this.streamToComponent(this.elements.thinkingText, flushed);
                } else if (mode === 'answer') {
                  this.streamToComponent(this.elements.responseText, flushed);
                }
              }
            }

            // Update fullBuffer for mode detection
            fullBuffer = tempBuffer;
          }

          // Flush any remaining buffer
          const remaining = bufferer.flush();
          if (remaining && mode !== 'initial') {
            if (mode === 'thinking') {
              this.streamToComponent(this.elements.thinkingText, remaining);
            } else if (mode === 'answer') {
              this.streamToComponent(this.elements.responseText, remaining);
            }
          }

          // Remove streaming cursor
          setTimeout(() => {
            this.elements.response.classList.remove('streaming');
          }, 1000);

        } catch (error) {
          this.elements.thinkingSection.style.display = 'none';
          this.elements.response.style.display = 'block';
          this.elements.responseText.textContent = 'Error: ' + error.message;
          console.error(error);
        }

        // Re-enable input
        this.elements.input.disabled = false;
        this.elements.input.focus();
      }
    }

    customElements.define('tlog-interface', TLogInterface);

    // Initialize the app
    const loadingContainer = document.getElementById('loadingContainer');
    const loadingText = document.getElementById('loadingText');
    const mainContent = document.getElementById('mainContent');
    const continueBtn = document.getElementById('continueBtn');
    const loadingGame = document.getElementById('loadingGame');

    async function initModels() {
      try {
        loadingText.textContent = 'Loading Qwen2.5-1.5B reasoning model...';

        const engine = await webllm.CreateMLCEngine(
          "Qwen2.5-1.5B-Instruct-q4f16_1-MLC",
          {
            initProgressCallback: (info) => {
              loadingText.textContent = info.text || 'Loading...';
            }
          }
        );

        // Show continue button
        loadingText.textContent = 'Model ready!';
        continueBtn.style.display = 'block';

        // Setup continue button
        continueBtn.addEventListener('click', () => {
          // Cleanup the game
          loadingGame.cleanup();

          loadingContainer.classList.add('hidden');
          mainContent.classList.add('visible');

          // Set the engine on the TLog interface
          const tlogInterface = document.querySelector('tlog-interface');
          tlogInterface.setEngine(engine);

          setTimeout(() => {
            const input = document.querySelector('#questionInput');
            if (input) input.focus();
          }, 500);
        });
      } catch (error) {
        loadingText.textContent = 'Error loading model: ' + error.message;
        console.error(error);
      }
    }

    initModels();
  </script>
</body>
</html>
