<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Branch Journal</title>
  <link rel="icon" type="image/x-icon" href="favicon.ico" />
  <script type="module" src="https://esm.run/@mlc-ai/web-llm"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: Georgia, serif;
      background: #faf9f7;
      color: #2c2c2c;
      min-height: 100vh;
      display: flex;
    }

    .tree-panel {
      width: 120px;
      min-width: 120px;
      background: #f5f4f2;
      border-right: 1px solid #e0ded8;
      padding: 20px 10px;
      overflow-y: auto;
    }

    .panel-section {
      margin-bottom: 20px;
    }

    .panel-section h2 {
      font-size: 10px;
      font-weight: normal;
      color: #999;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 10px;
    }

    .doc-list {
      list-style: none;
    }

    .doc-item {
      display: flex;
      align-items: center;
      padding: 6px 8px;
      margin-bottom: 4px;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.15s;
      font-size: 12px;
      color: #666;
    }

    .doc-item:hover {
      background: #eee;
    }

    .doc-item.active {
      background: #8b7355;
      color: #fff;
    }

    .doc-item-name {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .doc-item-delete {
      opacity: 0;
      background: none;
      border: none;
      color: inherit;
      cursor: pointer;
      padding: 0 4px;
      font-size: 14px;
    }

    .doc-item:hover .doc-item-delete {
      opacity: 0.5;
    }

    .doc-item-delete:hover {
      opacity: 1 !important;
    }

    .doc-item.active .doc-item-delete:hover {
      color: #ffcccc;
    }

    .new-doc-btn {
      display: block;
      width: 100%;
      background: none;
      border: 1px dashed #d0cec8;
      border-radius: 4px;
      color: #aaa;
      font-size: 11px;
      padding: 6px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .new-doc-btn:hover {
      background: #fff;
      border-color: #8b7355;
      border-style: solid;
      color: #8b7355;
    }

    .divider {
      height: 1px;
      background: #e0ded8;
      margin: 15px 0;
    }

    .annotations {
      position: absolute;
      left: 100%;
      margin-left: 15px;
      width: 280px;
      pointer-events: none;
    }

    .annotation-bubble {
      position: absolute;
      left: 0;
      background: #fff;
      border: 1px solid #e0ded8;
      border-radius: 8px;
      padding: 4px;
      pointer-events: auto;
      box-shadow: 0 2px 12px rgba(0,0,0,0.1);
      width: 280px;
    }

    .annotation-bubble::before {
      content: '';
      position: absolute;
      left: -6px;
      top: 16px;
      width: 10px;
      height: 10px;
      background: #fff;
      border-left: 1px solid #e0ded8;
      border-bottom: 1px solid #e0ded8;
      transform: rotate(45deg);
    }

    .annotation-item {
      padding: 10px 12px;
      font-size: 13px;
      line-height: 1.5;
      color: #444;
    }

    .annotation-item.insight {
      color: #555;
      cursor: pointer;
      transition: background 0.15s;
    }

    .annotation-item.insight:hover {
      background: #f5f4f2;
    }

    .annotation-item.insight::before {
      content: '→ ';
      color: #8b7355;
    }

    .annotation-item.insight.streaming {
      opacity: 0.7;
      cursor: default;
    }

    .annotation-item.insight.streaming:hover {
      background: transparent;
    }

    .annotation-item + .annotation-item {
      border-top: 1px solid #eee;
    }

    .annotation-loading {
      padding: 12px;
      color: #999;
      font-style: italic;
      font-size: 13px;
    }

    .annotation-loading.model-loading-status {
      font-size: 11px;
      word-break: break-word;
    }

    .annotation-actions {
      display: flex;
      gap: 6px;
      padding: 8px 12px;
      border-bottom: 1px solid #eee;
    }

    .annotation-action-btn {
      padding: 6px 12px;
      border: 1px solid #e0ded8;
      border-radius: 4px;
      background: #fff;
      font-size: 12px;
      color: #666;
      cursor: pointer;
      transition: all 0.15s;
    }

    .annotation-action-btn:hover {
      border-color: #8b7355;
      color: #8b7355;
    }

    .reword-input-wrap {
      padding: 10px 12px;
      border-bottom: 1px solid #eee;
    }

    .reword-input {
      width: 100%;
      padding: 8px 10px;
      border: 1px solid #e0ded8;
      border-radius: 4px;
      font-size: 13px;
      font-family: inherit;
      resize: none;
    }

    .reword-input:focus {
      outline: none;
      border-color: #8b7355;
    }

    .reword-input::placeholder {
      color: #aaa;
    }

    .reword-submit {
      margin-top: 8px;
      padding: 6px 12px;
      background: #8b7355;
      border: none;
      border-radius: 4px;
      color: #fff;
      font-size: 12px;
      cursor: pointer;
      transition: background 0.15s;
    }

    .reword-submit:hover {
      background: #6b5335;
    }

    .reword-submit:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    .reword-preview {
      padding: 12px;
      border-bottom: 1px solid #eee;
    }

    .reword-suggestion {
      font-size: 14px;
      line-height: 1.5;
      color: #333;
      padding: 10px 12px;
      background: #f8f7f5;
      border-radius: 6px;
      border-left: 3px solid #8b7355;
      margin-bottom: 10px;
    }

    .reword-preview-actions {
      display: flex;
      gap: 8px;
    }

    .reword-accept {
      padding: 6px 14px;
      background: #8b7355;
      border: none;
      border-radius: 4px;
      color: #fff;
      font-size: 12px;
      cursor: pointer;
      transition: background 0.15s;
    }

    .reword-accept:hover {
      background: #6b5335;
    }

    .reword-refine {
      padding: 6px 14px;
      background: #fff;
      border: 1px solid #8b7355;
      border-radius: 4px;
      color: #8b7355;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .reword-refine:hover {
      background: #8b7355;
      color: #fff;
    }

    .reword-cancel {
      padding: 6px 14px;
      background: none;
      border: 1px solid #ddd;
      border-radius: 4px;
      color: #888;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .reword-cancel:hover {
      border-color: #aaa;
      color: #666;
    }

    /* Settings */
    .settings-btn {
      position: fixed;
      top: 15px;
      right: 15px;
      background: none;
      border: 1px solid #e0ded8;
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 12px;
      color: #888;
      cursor: pointer;
      transition: all 0.15s;
      z-index: 50;
    }

    .settings-btn:hover {
      background: #fff;
      border-color: #8b7355;
      color: #8b7355;
    }

    .settings-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 200;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
    }

    .settings-overlay.open {
      opacity: 1;
      pointer-events: auto;
    }

    .settings-panel {
      background: #fff;
      border-radius: 12px;
      padding: 24px;
      width: 400px;
      max-width: 90vw;
      box-shadow: 0 10px 40px rgba(0,0,0,0.15);
      transform: translateY(10px);
      transition: transform 0.2s;
    }

    .settings-overlay.open .settings-panel {
      transform: translateY(0);
    }

    .settings-panel h2 {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 20px;
      color: #333;
    }

    .settings-group {
      margin-bottom: 20px;
    }

    .settings-group label {
      display: block;
      font-size: 12px;
      font-weight: 500;
      color: #666;
      margin-bottom: 6px;
    }

    .settings-group select,
    .settings-group input {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid #e0ded8;
      border-radius: 6px;
      font-size: 14px;
      color: #333;
      background: #fff;
    }

    .settings-group select:focus,
    .settings-group input:focus {
      outline: none;
      border-color: #8b7355;
    }

    .settings-group small {
      display: block;
      margin-top: 4px;
      font-size: 11px;
      color: #999;
    }

    .settings-row {
      display: flex;
      gap: 12px;
    }

    .settings-row .settings-group {
      flex: 1;
    }

    .settings-actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 24px;
      padding-top: 16px;
      border-top: 1px solid #eee;
    }

    .settings-actions button {
      padding: 10px 20px;
      border-radius: 6px;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .btn-cancel {
      background: none;
      border: 1px solid #ddd;
      color: #666;
    }

    .btn-cancel:hover {
      background: #f5f5f5;
    }

    .btn-save {
      background: #8b7355;
      border: none;
      color: #fff;
    }

    .btn-save:hover {
      background: #6b5335;
    }

    .status-dot {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 6px;
    }

    .status-dot.connected { background: #4a9; }
    .status-dot.disconnected { background: #d55; }
    .status-dot.loading { background: #da3; }

    .tree-svg {
      width: 100%;
    }

    .tree-node {
      cursor: pointer;
      transition: all 0.15s;
    }

    .tree-node circle {
      fill: #e0ded8;
      stroke: #ccc;
      stroke-width: 1.5px;
      transition: all 0.15s;
    }

    .tree-node:hover circle {
      fill: #d0cec8;
      stroke: #8b7355;
    }

    .tree-node.current circle {
      fill: #8b7355;
      stroke: #6b5335;
    }

    .tree-node.cached circle {
      stroke: #6a9955;
      stroke-width: 2px;
    }

    .tree-node.generating circle {
      animation: genpulse 1s ease-in-out infinite;
    }

    @keyframes genpulse {
      0%, 100% { stroke-opacity: 0.3; }
      50% { stroke-opacity: 1; stroke: #8b7355; }
    }

    .tree-node text {
      font-size: 8px;
      fill: #888;
      pointer-events: none;
    }

    .tree-node.current text {
      fill: #fff;
    }

    .tree-link {
      fill: none;
      stroke: #d0cec8;
      stroke-width: 1.5px;
    }

    .main-panel {
      flex: 1;
      padding: 40px 20px;
      overflow-y: auto;
    }

    .container {
      max-width: 700px;
      margin: 0 auto;
    }

    .editor-wrap {
      position: relative;
    }

    header {
      text-align: center;
      margin-bottom: 30px;
    }

    h1 {
      font-size: 24px;
      font-weight: normal;
      margin-bottom: 4px;
    }

    .subtitle {
      color: #888;
      font-size: 13px;
      font-style: italic;
    }

    .editor {
      min-height: 400px;
      padding: 20px;
      background: #fff;
      border: 1px solid #e0ded8;
      border-radius: 4px;
      font-size: 18px;
      line-height: 1.7;
      outline: none;
      white-space: pre-wrap;
    }

    .editor:empty::before {
      content: "Start writing...";
      color: #bbb;
      font-style: italic;
    }

    .ghost {
      color: #aaa;
    }

    .status {
      margin-top: 10px;
      font-size: 12px;
      color: #999;
      display: flex;
      justify-content: space-between;
    }

    .loading {
      position: fixed;
      inset: 0;
      background: #faf9f7;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      transition: opacity 0.3s;
      z-index: 100;
    }

    .loading.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .spinner {
      width: 30px;
      height: 30px;
      border: 2px solid #e0ded8;
      border-top-color: #8b7355;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 10px;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    .dots {
      display: inline-flex;
      gap: 3px;
    }

    .dots span {
      width: 4px;
      height: 4px;
      background: #8b7355;
      border-radius: 50%;
      animation: pulse 1s ease-in-out infinite;
    }

    .dots span:nth-child(2) { animation-delay: 0.2s; }
    .dots span:nth-child(3) { animation-delay: 0.4s; }

    @keyframes pulse {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 1; }
    }
  </style>
</head>
<body>
  <div class="loading" id="loading">
    <div class="spinner"></div>
    <div id="loadingText">Loading model...</div>
  </div>

  <button class="settings-btn" id="settingsBtn">⚙ Settings</button>

  <div class="settings-overlay" id="settingsOverlay">
    <div class="settings-panel">
      <h2>Settings</h2>

      <div class="settings-group">
        <label>Models</label>
        <small style="display: block; margin-bottom: 10px; color: #666;">
          <strong>Completion:</strong> Phi 3.5 Mini (3.8B)<br>
          <strong>Thinking:</strong> DeepSeek R1 8B
        </small>
      </div>

      <div class="settings-group">
        <label>Storage</label>
        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
          <button class="btn-cancel" id="clearModelsBtn">Clear Model Cache</button>
          <button class="btn-cancel" id="clearStorageBtn">Clear All Data</button>
        </div>
        <small style="margin-top: 8px; display: block;">Clear model cache to re-download models. Clear all data to reset documents and history.</small>
      </div>

      <div class="settings-actions">
        <button class="btn-cancel" id="settingsCancel">Close</button>
      </div>
    </div>
  </div>

  <div class="tree-panel">
    <div class="panel-section">
      <h2>Documents</h2>
      <ul class="doc-list" id="docList"></ul>
      <button class="new-doc-btn" id="newDocBtn">+ New</button>
    </div>
    <div class="divider"></div>
    <div class="panel-section">
      <h2>History</h2>
      <svg id="treeSvg" class="tree-svg"></svg>
    </div>
  </div>

  <div class="main-panel">
    <div class="container">
      <header>
        <h1>Branch Journal</h1>
        <p class="subtitle">Write freely. Tab to accept, Esc to dismiss, ⌘Z to undo.</p>
      </header>

      <div class="editor-wrap">
        <div class="annotations" id="annotations"></div>
        <div class="editor" id="editor" contenteditable="true" spellcheck="false"></div>
      </div>

      <div class="status">
        <span id="historyStatus"></span>
        <span id="generatingStatus"></span>
      </div>
    </div>
  </div>

  <script type="module">
    import * as webllm from "https://esm.run/@mlc-ai/web-llm";

    // ============================================
    // CONSTANTS
    // ============================================

    const MAX_CACHE_SIZE = 50;
    const SUGGESTIONS_PER_NODE = 3;
    const DEBOUNCE_MS = 300;
    const HISTORY_SAVE_MS = 2000;

    // Hardcoded model choices
    const COMPLETION_MODEL = 'webllm:Phi-3.5-mini-instruct-q4f16_1-MLC'; // 3.8B - good quality completions
    const THINKING_MODEL = 'webllm:DeepSeek-R1-Distill-Llama-8B-q4f16_1-MLC';

    // ============================================
    // STATE - Single source of truth
    // ============================================

    const createDocument = (id, name) => Object.freeze({
      id,
      name,
      content: '',
      history: Object.freeze({ nodes: {}, currentId: null, nextId: 1 }),
      createdAt: Date.now(),
    });

    const createAppState = () => ({
      // Persisted
      documents: {},
      currentDocId: null,
      nextDocId: 1,

      // Ephemeral (not persisted)
      suggestion: null,
      isGenerating: false,
      rewriteContext: null,
      suggestionCache: {},  // { [key]: { suggestions: [], status: 'pending'|'generating'|'ready' } }
      generationQueue: [],
      isProcessingQueue: false,
    });

    // Single mutable reference - all updates go through updateState
    let APP = createAppState();

    // Timers (kept separate as they're not serializable)
    const timers = {
      debounce: null,
      historySave: null,
      selection: null,
    };

    // WebLLM engine cache (not part of state - external resource)
    const engineCache = {};

    // ============================================
    // STATE SELECTORS (pure functions)
    // ============================================

    const getCurrentDoc = (state) => state.documents[state.currentDocId] || null;
    const getCurrentHistory = (state) => getCurrentDoc(state)?.history || { nodes: {}, currentId: null, nextId: 1 };
    const getCacheKey = (docId, nodeId) => `${docId}:${nodeId}`;


    // ============================================
    // STATE UPDATERS (immutable)
    // ============================================

    const updateState = (updater) => {
      APP = updater(APP);
    };

    const updateCache = (key, updates) => {
      updateState(s => ({
        ...s,
        suggestionCache: {
          ...s.suggestionCache,
          [key]: { ...s.suggestionCache[key], ...updates },
        },
      }));
    };

    const deleteFromCache = (key) => {
      updateState(s => {
        const { [key]: _, ...rest } = s.suggestionCache;
        return { ...s, suggestionCache: rest };
      });
    };

    // ============================================
    // SUGGESTION CACHE (uses state immutably)
    // ============================================

    // Simple hash for content comparison
    const hashContent = (content) => {
      let hash = 0;
      const str = content.slice(-200); // Only hash the last 200 chars for speed
      for (let i = 0; i < str.length; i++) {
        hash = ((hash << 5) - hash) + str.charCodeAt(i);
        hash |= 0;
      }
      return hash;
    };

    const getCachedSuggestions = (docId, nodeId, content) => {
      const key = getCacheKey(docId, nodeId);
      const cached = APP.suggestionCache[key];
      // Only return cache if content matches what was used to generate it
      if (cached && cached.contentHash === hashContent(content)) {
        return cached;
      }
      return null;
    };

    const queueSuggestionGeneration = (docId, nodeId, content, priority = false) => {
      if (!content || content.length < 10) return;

      const key = getCacheKey(docId, nodeId);
      const contentHash = hashContent(content);
      const existing = APP.suggestionCache[key];

      // Skip if already cached/generating for this exact content
      if (existing && existing.contentHash === contentHash) return;

      updateState(s => ({
        ...s,
        suggestionCache: {
          ...s.suggestionCache,
          [key]: { suggestions: [], status: 'pending', contentHash },
        },
        generationQueue: priority
          ? [{ docId, nodeId, content, key, contentHash }, ...s.generationQueue]
          : [...s.generationQueue, { docId, nodeId, content, key, contentHash }],
      }));

      scheduleQueueProcessing();
    };

    const scheduleQueueProcessing = () => {
      if (APP.isProcessingQueue || APP.generationQueue.length === 0) return;

      if ('requestIdleCallback' in window) {
        requestIdleCallback(() => processQueue(), { timeout: 2000 });
      } else {
        setTimeout(() => processQueue(), 100);
      }
    };

    const processQueue = async () => {
      if (APP.isProcessingQueue || APP.generationQueue.length === 0) return;

      updateState(s => ({ ...s, isProcessingQueue: true }));

      while (APP.generationQueue.length > 0) {
        // Dequeue task
        const task = APP.generationQueue[0];
        updateState(s => ({ ...s, generationQueue: s.generationQueue.slice(1) }));

        const cached = APP.suggestionCache[task.key];
        if (!cached || cached.status !== 'pending') continue;

        updateCache(task.key, { status: 'generating' });
        renderTree();

        try {
          const suggestions = [];
          for (let i = 0; i < SUGGESTIONS_PER_NODE; i++) {
            if (!APP.suggestionCache[task.key]) break;

            const suggestion = await generateSingleSuggestion(task.content, i);
            if (suggestion) suggestions.push(suggestion);

            await new Promise(r => setTimeout(r, 10));
          }

          updateCache(task.key, { suggestions, status: 'ready' });
          renderTree();
        } catch (e) {
          console.error('Background generation error:', e);
          deleteFromCache(task.key);
        }

        trimCache();
      }

      updateState(s => ({ ...s, isProcessingQueue: false }));
    };

    const generateSingleSuggestion = async (content, index) => {
      try {
        // Use last 1500 chars for context (enough for model to understand flow)
        const contextWindow = content.length > 1500 ? content.slice(-1500) : content;

        const messages = [
          {
            role: 'system',
            content: 'You are a text completion engine. The user will give you the beginning of a text. You must continue it naturally, writing ONLY the next few words or sentence. Do not repeat what was given. Do not add quotes. Do not explain. Just continue the text seamlessly.',
          },
          {
            role: 'user',
            content: `Continue this text naturally:\n\n${contextWindow}`,
          },
        ];

        let result = await llmComplete(COMPLETION_MODEL, messages, {
          temperature: 0.7 + (index * 0.15),
          max_tokens: 60,
        });

        // Clean up common issues
        if (result) {
          result = result.replace(/^["']|["']$/g, '').trim();
          // Remove if it starts by repeating the end of content
          const lastWords = content.split(/\s+/).slice(-3).join(' ');
          if (result.toLowerCase().startsWith(lastWords.toLowerCase())) {
            result = result.slice(lastWords.length).trim();
          }
        }
        return result;
      } catch (e) {
        console.error('Generation error:', e);
        return null;
      }
    };

    const trimCache = () => {
      const keys = Object.keys(APP.suggestionCache);
      if (keys.length <= MAX_CACHE_SIZE) return;

      // Remove oldest entries
      const keysToDelete = keys.slice(0, keys.length - MAX_CACHE_SIZE);
      updateState(s => {
        const newCache = { ...s.suggestionCache };
        keysToDelete.forEach(k => delete newCache[k]);
        return { ...s, suggestionCache: newCache };
      });
    };

    const clearCacheForDoc = (docId) => {
      updateState(s => {
        const newCache = {};
        Object.entries(s.suggestionCache).forEach(([key, value]) => {
          if (!key.startsWith(`${docId}:`)) {
            newCache[key] = value;
          }
        });
        return { ...s, suggestionCache: newCache };
      });
    };

    const prioritizeCurrentNode = () => {
      const doc = getCurrentDoc(APP);
      if (!doc) return;

      const { currentId } = doc.history;
      const node = doc.history.nodes[currentId];
      if (!node) return;

      const key = getCacheKey(doc.id, currentId);

      // Move current node to front of queue if pending
      const idx = APP.generationQueue.findIndex(t => t.key === key);
      if (idx > 0) {
        updateState(s => {
          const queue = [...s.generationQueue];
          const [task] = queue.splice(idx, 1);
          return { ...s, generationQueue: [task, ...queue] };
        });
      }

      // Queue if not already queued (use plain text)
      if (!APP.suggestionCache[key]) {
        const plainText = normalizeForComparison(node.content);
        queueSuggestionGeneration(doc.id, currentId, plainText, true);
      }
    };

    const queueExistingNodes = () => {
      prioritizeCurrentNode();

      const doc = getCurrentDoc(APP);
      if (!doc) return;

      const nodes = Object.values(doc.history.nodes)
        .sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0))
        .slice(0, 10);

      nodes.forEach(node => {
        if (node.content && node.content.length >= 10) {
          const plainText = normalizeForComparison(node.content);
          queueSuggestionGeneration(doc.id, node.id, plainText, false);
        }
      });
    };

    // ============================================
    // SUGGESTION STATE UPDATES
    // ============================================

    const startSuggestion = (mode, original = '') => {
      updateState(s => ({
        ...s,
        suggestion: { mode, branches: [''], selected: 0, original },
        isGenerating: true,
      }));
    };

    const appendToSuggestion = (branchIndex, text) => {
      if (!APP.suggestion) return;
      updateState(s => {
        const branches = [...s.suggestion.branches];
        branches[branchIndex] = (branches[branchIndex] || '') + text;
        return { ...s, suggestion: { ...s.suggestion, branches } };
      });
    };

    const addSuggestionBranch = () => {
      if (!APP.suggestion) return;
      updateState(s => ({
        ...s,
        suggestion: {
          ...s.suggestion,
          branches: [...s.suggestion.branches, ''],
        },
      }));
    };

    const selectSuggestion = (index) => {
      if (!APP.suggestion) return;
      const len = APP.suggestion.branches.length;
      const selected = ((index % len) + len) % len;
      updateState(s => ({ ...s, suggestion: { ...s.suggestion, selected } }));
    };

    const clearSuggestion = () => {
      updateState(s => ({ ...s, suggestion: null, isGenerating: false }));
    };

    const setGenerating = (isGenerating) => {
      updateState(s => ({ ...s, isGenerating }));
    };

    // ============================================
    // DOCUMENT MANAGEMENT
    // ============================================

    const addDocument = (name) => {
      const id = APP.nextDocId;
      const doc = createDocument(id, name || `Untitled ${id}`);
      updateState(s => ({
        ...s,
        documents: { ...s.documents, [id]: doc },
        currentDocId: id,
        nextDocId: id + 1,
      }));
      persistState();
      return id;
    };

    const switchDocument = (docId) => {
      if (!APP.documents[docId]) return;

      // Save current doc content first
      if (APP.currentDocId && APP.documents[APP.currentDocId]) {
        const content = getEditorContent();
        updateDocContent(content);
      }

      updateState(s => ({ ...s, currentDocId: docId, suggestion: null }));
      persistState();
    };

    const deleteDocument = (docId) => {
      updateState(s => {
        const { [docId]: _, ...docs } = s.documents;
        let newCurrentId = s.currentDocId;
        if (docId === s.currentDocId) {
          const remaining = Object.keys(docs);
          newCurrentId = remaining.length > 0 ? parseInt(remaining[0]) : null;
        }
        return { ...s, documents: docs, currentDocId: newCurrentId };
      });
      persistState();
    };

    const renameDocument = (docId, newName) => {
      if (!APP.documents[docId]) return;
      updateState(s => ({
        ...s,
        documents: {
          ...s.documents,
          [docId]: { ...s.documents[docId], name: newName },
        },
      }));
      persistState();
    };

    const updateDocContent = (content) => {
      const doc = getCurrentDoc(APP);
      if (!doc) return;
      updateState(s => ({
        ...s,
        documents: {
          ...s.documents,
          [doc.id]: { ...s.documents[doc.id], content },
        },
      }));
    };

    // ============================================
    // HISTORY (Tree-based undo)
    // ============================================

    const normalizeForComparison = (html) => {
      // Convert HTML to plain text and normalize whitespace for comparison
      const temp = document.createElement('div');
      temp.innerHTML = html;
      return (temp.textContent || '').trim().replace(/\s+/g, ' ');
    };

    const saveToHistory = (content, label = 'edit') => {
      const doc = getCurrentDoc(APP);
      if (!doc) return;

      const { nodes, currentId, nextId } = doc.history;

      // Don't save if semantically the same
      if (currentId && nodes[currentId]) {
        const currentNorm = normalizeForComparison(nodes[currentId].content);
        const newNorm = normalizeForComparison(content);
        if (currentNorm === newNorm) return;
      }

      const newNode = {
        id: nextId,
        content,
        timestamp: Date.now(),
        label,
        parent: currentId,
        children: [],
      };

      const newNodes = { ...nodes, [nextId]: newNode };

      if (currentId && newNodes[currentId]) {
        newNodes[currentId] = {
          ...newNodes[currentId],
          children: [...newNodes[currentId].children, nextId],
        };
      }

      const newHistory = { nodes: newNodes, currentId: nextId, nextId: nextId + 1 };

      updateState(s => ({
        ...s,
        documents: {
          ...s.documents,
          [doc.id]: { ...doc, history: newHistory, content },
        },
      }));

      // Queue background suggestion generation
      const plainText = normalizeForComparison(content);
      queueSuggestionGeneration(doc.id, nextId, plainText, true);

      persistState();
    };

    const undo = () => {
      const doc = getCurrentDoc(APP);
      if (!doc) return null;

      const { nodes, currentId } = doc.history;
      const current = nodes[currentId];
      if (current?.parent && nodes[current.parent]) {
        updateState(s => ({
          ...s,
          documents: {
            ...s.documents,
            [doc.id]: { ...doc, history: { ...doc.history, currentId: current.parent } },
          },
        }));
        return nodes[current.parent].content;
      }
      return null;
    };

    const redo = () => {
      const doc = getCurrentDoc(APP);
      if (!doc) return null;

      const { nodes, currentId } = doc.history;
      const current = nodes[currentId];
      if (current?.children.length > 0) {
        const childId = current.children[current.children.length - 1];
        updateState(s => ({
          ...s,
          documents: {
            ...s.documents,
            [doc.id]: { ...doc, history: { ...doc.history, currentId: childId } },
          },
        }));
        return nodes[childId].content;
      }
      return null;
    };

    const switchBranch = (delta) => {
      const doc = getCurrentDoc(APP);
      if (!doc) return null;

      const { nodes, currentId } = doc.history;
      const current = nodes[currentId];
      if (!current?.parent) return null;

      const parent = nodes[current.parent];
      const siblings = parent.children;
      const myIndex = siblings.indexOf(currentId);
      const newIndex = myIndex + delta;

      if (newIndex >= 0 && newIndex < siblings.length) {
        const siblingId = siblings[newIndex];
        updateState(s => ({
          ...s,
          documents: {
            ...s.documents,
            [doc.id]: { ...doc, history: { ...doc.history, currentId: siblingId } },
          },
        }));
        return nodes[siblingId].content;
      }
      return null;
    };

    const getHistoryInfo = () => {
      const history = getCurrentHistory(APP);
      const { nodes, currentId } = history;
      if (!currentId) return '';

      const current = nodes[currentId];
      let depth = 0;
      let node = current;
      while (node?.parent) {
        depth++;
        node = nodes[node.parent];
      }

      const hasSiblings = current?.parent && nodes[current.parent].children.length > 1;
      const hasChildren = current?.children.length > 0;

      let info = `v${currentId}`;
      if (hasSiblings) info += ' ⑂';
      if (hasChildren) info += ' →';
      return info;
    };

    // ============================================
    // PERSISTENCE
    // ============================================

    const persistState = () => {
      localStorage.setItem('journal-state', JSON.stringify({
        documents: APP.documents,
        currentDocId: APP.currentDocId,
        nextDocId: APP.nextDocId,
      }));
    };


    const loadPersistedState = () => {
      try {
        const saved = localStorage.getItem('journal-state');
        if (saved) {
          const parsed = JSON.parse(saved);
          updateState(s => ({
            ...s,
            documents: parsed.documents || {},
            currentDocId: parsed.currentDocId,
            nextDocId: parsed.nextDocId || 1,
          }));
        }

        // Migrate old format
        const oldContent = localStorage.getItem('journal-content');
        const oldHistory = localStorage.getItem('journal-history');
        if (oldContent || oldHistory) {
          const id = addDocument('Imported');
          updateState(s => ({
            ...s,
            documents: {
              ...s.documents,
              [id]: {
                ...s.documents[id],
                content: oldContent || '',
                history: oldHistory ? JSON.parse(oldHistory) : s.documents[id].history,
              },
            },
          }));
          localStorage.removeItem('journal-content');
          localStorage.removeItem('journal-history');
          persistState();
        }

        return getCurrentDoc(APP)?.content || '';
      } catch (e) {
        console.error('Failed to load state:', e);
        return '';
      }
    };

    // ============================================
    // DOM HELPERS
    // ============================================

    const $ = (id) => document.getElementById(id);

    const getEditorContent = () => {
      const clone = $('editor').cloneNode(true);
      clone.querySelector('.ghost')?.remove();
      return clone.innerHTML;
    };

    const getTextBeforeCursor = () => {
      const sel = window.getSelection();
      if (!sel.rangeCount) return '';

      const range = sel.getRangeAt(0);
      const preRange = document.createRange();
      preRange.setStart($('editor'), 0);
      preRange.setEnd(range.startContainer, range.startOffset);

      const fragment = preRange.cloneContents();
      fragment.querySelector('.ghost')?.remove();
      return fragment.textContent || '';
    };

    const getPlainText = () => {
      const editor = $('editor');
      const clone = editor.cloneNode(true);
      clone.querySelector('.ghost')?.remove();
      // Convert <br> and block elements to newlines
      clone.querySelectorAll('br').forEach(br => br.replaceWith('\n'));
      clone.querySelectorAll('div, p').forEach(el => {
        el.before('\n');
        el.after('');
      });
      return (clone.textContent || '').trim();
    };

    const getSelectedText = () => {
      const sel = window.getSelection();
      return sel.toString().trim();
    };

    const insertGhost = (text) => {
      removeGhost();

      const ghost = document.createElement('span');
      ghost.className = 'ghost';
      ghost.contentEditable = 'false';
      ghost.textContent = text || '\u200B';

      const sel = window.getSelection();
      if (sel.rangeCount > 0) {
        const range = sel.getRangeAt(0);
        range.collapse(false);
        range.insertNode(ghost);
        range.setStartBefore(ghost);
        range.collapse(true);
        sel.removeAllRanges();
        sel.addRange(range);
      } else {
        $('editor').appendChild(ghost);
      }

      return ghost;
    };

    const updateGhost = (text) => {
      const ghost = $('editor').querySelector('.ghost');
      if (ghost) {
        ghost.textContent = text || '\u200B';
      }
    };

    const removeGhost = () => {
      $('editor').querySelector('.ghost')?.remove();
    };

    const acceptGhost = () => {
      const ghost = $('editor').querySelector('.ghost');
      if (ghost) {
        ghost.classList.remove('ghost');
        ghost.removeAttribute('contentEditable');
      }
    };

    const setEditorContent = (html) => {
      $('editor').innerHTML = html;
      // Move cursor to end
      const range = document.createRange();
      range.selectNodeContents($('editor'));
      range.collapse(false);
      const sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
    };

    const render = () => {
      // History status
      $('historyStatus').textContent = getHistoryInfo();

      // Generating status
      $('generatingStatus').innerHTML = APP.isGenerating
        ? '<span class="dots"><span></span><span></span><span></span></span>'
        : '';

      // Render document list
      renderDocList();

      // Render tree
      renderTree();
    };

    const renderDocList = () => {
      const list = $('docList');
      list.innerHTML = '';

      const docs = Object.values(APP.documents).sort((a, b) => b.createdAt - a.createdAt);

      docs.forEach(doc => {
        const li = document.createElement('li');
        li.className = `doc-item ${doc.id === APP.currentDocId ? 'active' : ''}`;

        const name = document.createElement('span');
        name.className = 'doc-item-name';
        name.textContent = doc.name;
        name.addEventListener('dblclick', (e) => {
          e.stopPropagation();
          const newName = prompt('Rename document:', doc.name);
          if (newName && newName.trim()) {
            renameDocument(doc.id, newName.trim());
            render();
          }
        });

        const del = document.createElement('button');
        del.className = 'doc-item-delete';
        del.textContent = '×';
        del.addEventListener('click', (e) => {
          e.stopPropagation();
          if (confirm(`Delete "${doc.name}"?`)) {
            deleteDocument(doc.id);
            if (getCurrentDoc(APP)) {
              setEditorContent(getCurrentDoc(APP).content);
            } else {
              $('editor').innerHTML = '';
            }
            render();
          }
        });

        li.appendChild(name);
        li.appendChild(del);

        li.addEventListener('click', () => {
          if (doc.id !== APP.currentDocId) {
            switchDocument(doc.id);
            setEditorContent(getCurrentDoc(APP).content);
            render();
          }
        });

        list.appendChild(li);
      });
    };

    // ============================================
    // TREE VISUALIZATION
    // ============================================

    const renderTree = () => {
      const svg = d3.select('#treeSvg');
      svg.selectAll('*').remove();

      const history = getCurrentHistory(APP);
      const { nodes, currentId } = history;
      const nodeList = Object.values(nodes);

      if (nodeList.length === 0) return;

      // Find root (node with no parent)
      const root = nodeList.find(n => !n.parent);
      if (!root) return;

      // Build hierarchy
      const buildHierarchy = (nodeId) => {
        const node = nodes[nodeId];
        if (!node) return null;
        return {
          id: node.id,
          label: node.label,
          children: node.children.map(buildHierarchy).filter(Boolean),
        };
      };

      const hierarchyData = buildHierarchy(root.id);
      if (!hierarchyData) return;

      const hierarchy = d3.hierarchy(hierarchyData);

      // Calculate dimensions
      const nodeRadius = 8;
      const levelHeight = 35;
      const siblingSpacing = 25;

      // Count max width at any level
      const levels = [];
      hierarchy.each(d => {
        levels[d.depth] = (levels[d.depth] || 0) + 1;
      });
      const maxWidth = Math.max(...levels, 1);

      const width = Math.max(100, maxWidth * siblingSpacing + 20);
      const height = (hierarchy.height + 1) * levelHeight + 20;

      svg.attr('viewBox', `0 0 ${width} ${height}`)
         .attr('height', height);

      // Create tree layout
      const treeLayout = d3.tree()
        .size([width - 20, height - 40])
        .separation((a, b) => 1);

      const treeData = treeLayout(hierarchy);

      // Draw links
      svg.selectAll('.tree-link')
        .data(treeData.links())
        .join('path')
        .attr('class', 'tree-link')
        .attr('d', d3.linkVertical()
          .x(d => d.x + 10)
          .y(d => d.y + 20));

      // Draw nodes
      const doc = getCurrentDoc(APP);
      const docId = doc?.id;

      const nodeGroups = svg.selectAll('.tree-node')
        .data(treeData.descendants())
        .join('g')
        .attr('class', d => {
          const classes = ['tree-node'];
          if (d.data.id === currentId) classes.push('current');

          // Check cache status (use raw content for tree - exact match not critical here)
          if (docId) {
            const key = getCacheKey(docId, d.data.id);
            const cached = APP.suggestionCache[key];
            if (cached?.status === 'ready') classes.push('cached');
            else if (cached?.status === 'generating') classes.push('generating');
          }

          return classes.join(' ');
        })
        .attr('transform', d => `translate(${d.x + 10}, ${d.y + 20})`)
        .on('click', (event, d) => {
          navigateToNode(d.data.id);
        });

      nodeGroups.append('circle')
        .attr('r', nodeRadius);

      nodeGroups.append('text')
        .attr('dy', 3)
        .attr('text-anchor', 'middle')
        .text(d => d.data.id);
    };

    const navigateToNode = (nodeId) => {
      const doc = getCurrentDoc(APP);
      if (!doc) return;

      const { nodes } = doc.history;
      if (!nodes[nodeId]) return;

      updateState(s => ({
        ...s,
        documents: {
          ...s.documents,
          [doc.id]: { ...doc, history: { ...doc.history, currentId: nodeId } },
        },
      }));

      const content = nodes[nodeId].content;
      setEditorContent(content);
      updateDocContent(content);
      persistState();
      clearSuggestion();
      removeGhost();
      render();

      prioritizeCurrentNode();
    };

    const handleNewDocument = () => {
      // Save current content first
      if (getCurrentDoc(APP)) {
        const content = getEditorContent();
        updateDocContent(content);
      }

      addDocument();
      $('editor').innerHTML = '';
      $('editor').focus();
      render();
    };

    // ============================================
    // LLM
    // ============================================

    const complete = async (context) => {
      const doc = getCurrentDoc(APP);
      if (!doc) return;

      const { currentId } = doc.history;

      // Check cache first (only if we have a valid history node and content matches)
      if (currentId) {
        const cached = getCachedSuggestions(doc.id, currentId, context);
        if (cached && cached.status === 'ready' && cached.suggestions.length > 0) {
          // Use cached suggestions instantly
          updateState(s => ({
            ...s,
            suggestion: {
              mode: 'complete',
              branches: [...cached.suggestions],
              selected: 0,
              original: '',
            },
            isGenerating: false,
          }));
          insertGhost(cached.suggestions[0]);
          render();
          return;
        }
      }

      // Fall back to streaming generation
      startSuggestion('complete');
      insertGhost('');
      render();

      // Use last 1500 chars for context
      const contextWindow = context.length > 1500 ? context.slice(-1500) : context;

      try {
        const messages = [
          {
            role: 'system',
            content: 'You are a text completion engine. Continue the text naturally, writing ONLY the next few words or sentence. Do not repeat what was given. Do not add quotes. Do not explain. Just continue seamlessly.',
          },
          {
            role: 'user',
            content: `Continue this text naturally:\n\n${contextWindow}`,
          },
        ];

        for await (const token of llmStream(COMPLETION_MODEL, messages, { temperature: 0.8, max_tokens: 60 })) {
          if (!APP.suggestion || APP.suggestion.mode !== 'complete') break;
          if (token) {
            appendToSuggestion(0, token);
            updateGhost(APP.suggestion.branches[APP.suggestion.selected]);
          }
        }

        // Start additional branches after a delay
        setTimeout(() => generateMoreBranches(context, 'complete'), 1000);

      } catch (e) {
        console.error('Completion error:', e);
        clearSuggestion();
        removeGhost();
      } finally {
        setGenerating(false);
        render();
      }
    };

    const generateMoreBranches = async (context, mode) => {
      if (!APP.suggestion || APP.suggestion.mode !== mode) return;

      // Use last 1500 chars for context
      const contextWindow = context.length > 1500 ? context.slice(-1500) : context;

      for (let i = 1; i < 3; i++) {
        if (!APP.suggestion || APP.suggestion.mode !== mode) break;

        addSuggestionBranch();
        setGenerating(true);
        render();

        try {
          const messages = [
            {
              role: 'system',
              content: 'You are a text completion engine. Continue the text naturally, writing ONLY the next few words or sentence. Do not repeat what was given. Do not add quotes. Do not explain. Just continue seamlessly.',
            },
            {
              role: 'user',
              content: `Continue this text naturally:\n\n${contextWindow}`,
            },
          ];

          for await (const token of llmStream(COMPLETION_MODEL, messages, { temperature: 0.8 + (i * 0.15), max_tokens: 60 })) {
            if (!APP.suggestion || APP.suggestion.mode !== mode) break;
            if (token) {
              appendToSuggestion(i, token);
              if (APP.suggestion.selected === i) {
                updateGhost(APP.suggestion.branches[i]);
              }
            }
          }
        } catch (e) {
          console.error('Branch error:', e);
        }
      }

      setGenerating(false);
      render();
    };

    // ============================================
    // EVENT HANDLERS
    // ============================================

    const handleInput = () => {
      clearSuggestion();
      removeGhost();
      clearAnnotations();

      const content = getEditorContent();
      updateDocContent(content);
      persistState();

      // Debounced completion
      clearTimeout(timers.debounce);
      timers.debounce = setTimeout(() => {
        const text = getTextBeforeCursor();
        if (text.length >= 10) {
          complete(text);
        }
      }, 300);

      // Debounced history save
      clearTimeout(timers.historySave);
      timers.historySave = setTimeout(() => {
        saveToHistory(content, 'typing');
      }, 2000);
    };

    const handleSelectionChange = () => {
      // Don't clear if we're interacting with the annotation bubble (e.g., reword input)
      const activeEl = document.activeElement;
      if (activeEl?.closest('.annotation-bubble')) return;

      // Clear annotations if no selection or typing
      const selected = getSelectedText();
      if (selected.length < 5) {
        clearAnnotations();
        return;
      }

      // Don't interfere with existing suggestion
      if (APP.suggestion) return;

      clearTimeout(timers.selection);
      timers.selection = setTimeout(() => {
        const sel = window.getSelection();
        const currentSelected = sel.toString().trim();
        if (currentSelected === selected && currentSelected.length >= 5) {
          showRewriteAnnotations(selected, sel);
        }
      }, 600);
    };

    const clearAnnotations = () => {
      $('annotations').innerHTML = '';
      updateState(s => ({ ...s, rewriteContext: null }));
    };

    const getSelectionContext = (selection, windowSize = 300) => {
      const range = selection.getRangeAt(0);
      const editor = $('editor');
      const selectedText = range.toString();

      try {
        // Get text before selection
        const preRange = document.createRange();
        preRange.setStart(editor, 0);
        preRange.setEnd(range.startContainer, range.startOffset);
        const preText = preRange.toString();
        const prefix = preText.length > windowSize
          ? '...' + preText.slice(-windowSize)
          : preText;

        // Get text after selection
        const postRange = document.createRange();
        postRange.setStart(range.endContainer, range.endOffset);
        postRange.setEnd(editor, editor.childNodes.length);
        const postText = postRange.toString();
        const suffix = postText.length > windowSize
          ? postText.slice(0, windowSize) + '...'
          : postText;

        return { selectedText, prefix, suffix };
      } catch (e) {
        return { selectedText, prefix: '', suffix: '' };
      }
    };

    const showRewriteAnnotations = async (text, selection) => {
      const range = selection.getRangeAt(0);
      const rect = range.getBoundingClientRect();
      const editorRect = $('editor').getBoundingClientRect();
      const topOffset = rect.top - editorRect.top;

      // Get surrounding context for better insights
      const { selectedText, prefix, suffix } = getSelectionContext(selection);

      // Store context for applying later
      updateState(s => ({ ...s, rewriteContext: { text, range: range.cloneRange(), prefix, suffix } }));

      // Show initial bubble with actions and streaming area
      const container = $('annotations');
      container.innerHTML = '';

      const bubble = document.createElement('div');
      bubble.className = 'annotation-bubble';
      bubble.style.top = `${topOffset}px`;

      // Action buttons (always visible at top)
      const actions = document.createElement('div');
      actions.className = 'annotation-actions';
      const rewordBtn = document.createElement('button');
      rewordBtn.className = 'annotation-action-btn';
      rewordBtn.textContent = 'Reword';
      rewordBtn.addEventListener('click', () => showRewordInput(bubble));
      actions.appendChild(rewordBtn);
      bubble.appendChild(actions);

      // Streaming insights area
      const insightsArea = document.createElement('div');
      insightsArea.className = 'annotation-insights';
      insightsArea.innerHTML = '<div class="annotation-loading model-loading-status">Pondering...</div>';
      bubble.appendChild(insightsArea);

      container.appendChild(bubble);

      try {
        // Check if selection changed
        if (!APP.rewriteContext || APP.rewriteContext.text !== text) return;

        // Check if model needs to load - show loading status
        const [, modelId] = THINKING_MODEL.split(':');
        if (!engineCache[modelId]) {
          insightsArea.innerHTML = '<div class="annotation-loading model-loading-status">Loading DeepSeek R1...</div>';
        }

        // Build context-aware prompt
        const hasContext = prefix || suffix;
        const contextBlock = hasContext
          ? `CONTEXT (for understanding only):
${prefix ? `[Before]: ${prefix}\n` : ''}[SELECTED TEXT - focus your analysis here]: ${selectedText}
${suffix ? `[After]: ${suffix}` : ''}`
          : selectedText;

        const messages = [
          {
            role: 'system',
            content: `You are a thoughtful thinking partner helping a writer refine their work. You'll be given a selected passage along with surrounding context. Generate 2-3 probing questions or insights about the SELECTED TEXT to help the writer think more deeply. Use the surrounding context to understand the flow, but focus your questions on the selected portion.

Focus on:
- Assumptions that might be worth examining
- Perspectives not yet considered
- Implications or consequences
- Clarity of reasoning
- What's left unsaid

Format: One question or insight per line. Be concise but thought-provoking. No numbering or bullets.`
          },
          { role: 'user', content: contextBlock },
        ];

        let fullResponse = '';
        let hasStarted = false;
        let thinkingIndicator = null;
        let inThinkBlock = false;
        let currentStreamingEl = null;
        let processedContent = '';

        const createInsightElement = (isStreaming = false) => {
          const item = document.createElement('div');
          item.className = 'annotation-item insight' + (isStreaming ? ' streaming' : '');
          insightsArea.appendChild(item);
          return item;
        };

        const addFinalizedInsight = (text) => {
          const trimmed = text.trim();
          if (trimmed.length <= 5) return null;
          const item = createInsightElement(false);
          item.textContent = trimmed;
          item.addEventListener('click', () => {
            generateInsightCompletion(trimmed);
          });
          return item;
        };

        for await (const token of llmStream(THINKING_MODEL, messages, {
          temperature: 0.8,
          max_tokens: 500,
        })) {
          if (!APP.rewriteContext || APP.rewriteContext.text !== text) break;

          fullResponse += token;

          if (!hasStarted) {
            insightsArea.innerHTML = '';
            hasStarted = true;
          }

          // Check if we're in a think block
          const hasThinkOpen = fullResponse.includes('<think>');
          const hasThinkClose = fullResponse.includes('</think>');
          inThinkBlock = hasThinkOpen && !hasThinkClose;

          if (inThinkBlock) {
            // Show thinking indicator
            if (!thinkingIndicator) {
              thinkingIndicator = document.createElement('div');
              thinkingIndicator.className = 'annotation-loading';
              thinkingIndicator.textContent = 'Reasoning...';
              insightsArea.appendChild(thinkingIndicator);
            }
          } else {
            // Remove thinking indicator when done thinking
            if (thinkingIndicator) {
              thinkingIndicator.remove();
              thinkingIndicator = null;
            }

            // Extract content after </think>
            let content = fullResponse;
            if (hasThinkClose) {
              content = fullResponse.split('</think>').pop() || '';
            }

            // Stream the content
            const lines = content.split('\n');
            const completedLines = lines.slice(0, -1);
            const currentLine = lines[lines.length - 1] || '';

            // Finalize completed lines we haven't processed yet
            const newCompletedContent = completedLines.join('\n');
            if (newCompletedContent.length > processedContent.length) {
              const newPart = newCompletedContent.substring(processedContent.length);
              const newLines = newPart.split('\n').filter(l => l.trim());

              // Remove current streaming element before adding finalized
              if (currentStreamingEl) {
                currentStreamingEl.remove();
                currentStreamingEl = null;
              }

              newLines.forEach(line => {
                addFinalizedInsight(line);
              });

              processedContent = newCompletedContent;
            }

            // Update streaming element with current line
            if (currentLine.trim()) {
              if (!currentStreamingEl) {
                currentStreamingEl = createInsightElement(true);
              }
              currentStreamingEl.textContent = currentLine.trim();
            }
          }
        }

        // Finalize any remaining streaming content
        if (currentStreamingEl) {
          const finalText = currentStreamingEl.textContent.trim();
          currentStreamingEl.remove();
          if (finalText.length > 5) {
            addFinalizedInsight(finalText);
          }
        }

        // Clean up thinking indicator if still present
        if (thinkingIndicator) {
          thinkingIndicator.remove();
        }

        // If no insights were generated, show a message
        if (insightsArea.children.length === 0) {
          insightsArea.innerHTML = '<div class="annotation-item" style="color: #999; font-style: italic;">No insights generated</div>';
        }

      } catch (e) {
        console.error('Insight error:', e);
        insightsArea.innerHTML = '<div class="annotation-item" style="color: #c55;">Failed to generate insights</div>';
      }
    };

    const renderAnnotations = (insights, topOffset) => {
      const container = $('annotations');
      container.innerHTML = '';

      const bubble = document.createElement('div');
      bubble.className = 'annotation-bubble';
      bubble.style.top = `${topOffset}px`;

      // Action buttons
      const actions = document.createElement('div');
      actions.className = 'annotation-actions';

      const rewordBtn = document.createElement('button');
      rewordBtn.className = 'annotation-action-btn';
      rewordBtn.textContent = 'Reword';
      rewordBtn.addEventListener('click', () => showRewordInput(bubble, topOffset));
      actions.appendChild(rewordBtn);

      bubble.appendChild(actions);

      // Insights
      insights.forEach((insight) => {
        const item = document.createElement('div');
        item.className = 'annotation-item insight';
        item.textContent = insight;
        item.addEventListener('click', () => {
          generateInsightCompletion(insight);
        });
        bubble.appendChild(item);
      });

      container.appendChild(bubble);
    };

    const showRewordInput = (bubble, placeholder = 'How should it be reworded? (e.g., "make it more casual")') => {
      // Remove existing reword input if any
      bubble.querySelector('.reword-input-wrap')?.remove();
      bubble.querySelector('.reword-preview')?.remove();

      const wrap = document.createElement('div');
      wrap.className = 'reword-input-wrap';

      const input = document.createElement('textarea');
      input.className = 'reword-input';
      input.placeholder = placeholder;
      input.rows = 2;

      const submit = document.createElement('button');
      submit.className = 'reword-submit';
      submit.textContent = 'Reword';

      submit.addEventListener('click', () => {
        if (input.value.trim()) {
          applyReword(input.value.trim(), bubble);
        }
      });

      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          if (input.value.trim()) {
            applyReword(input.value.trim(), bubble);
          }
        }
      });

      wrap.appendChild(input);
      wrap.appendChild(submit);

      // Insert after actions
      const actions = bubble.querySelector('.annotation-actions');
      actions.after(wrap);

      input.focus();
    };

    const applyReword = async (instruction, bubble) => {
      const context = APP.rewriteContext;
      if (!context) return;

      const selectedText = context.text;

      // Store instruction history for refinements
      if (!context.instructions) {
        updateState(s => ({
          ...s,
          rewriteContext: { ...s.rewriteContext, instructions: [instruction] },
        }));
      } else {
        updateState(s => ({
          ...s,
          rewriteContext: {
            ...s.rewriteContext,
            instructions: [...s.rewriteContext.instructions, instruction]
          },
        }));
      }

      // Show loading state in bubble
      showRewordLoading(bubble);

      try {
        const allInstructions = APP.rewriteContext.instructions || [instruction];
        const instructionContext = allInstructions.length > 1
          ? `Previous instructions: ${allInstructions.slice(0, -1).join(' → ')}\nLatest instruction: ${allInstructions[allInstructions.length - 1]}`
          : `Instruction: ${instruction}`;

        const messages = [
          {
            role: 'system',
            content: `You are a skilled editor helping a writer revise their own work. Your job is to reword text while:
- Preserving the author's authentic voice and tone
- Understanding the SPIRIT of instructions (e.g., "thoughtful" means reflective/considered, NOT formal/academic)
- Keeping it natural and human - never corporate, stiff, or AI-sounding
- Maintaining roughly the same length unless asked otherwise

Output ONLY the reworded text. No quotes, no explanation, no preamble.`,
          },
          {
            role: 'user',
            content: `Reword this: "${selectedText}"\n\n${instructionContext}`,
          },
        ];

        const reworded = await llmComplete(THINKING_MODEL, messages, {
          temperature: 0.7,
          max_tokens: 200,
        });

        if (reworded) {
          // Clean up the result
          const cleaned = reworded.trim().replace(/^["']|["']$/g, '');

          // Show preview in bubble instead of applying directly
          showRewordPreview(bubble, selectedText, cleaned);
        }
      } catch (e) {
        console.error('Reword error:', e);
        showRewordError(bubble);
      }
    };

    const showRewordLoading = (bubble) => {
      const wrap = bubble.querySelector('.reword-input-wrap');
      if (wrap) {
        wrap.innerHTML = '<div class="annotation-loading">Thinking...</div>';
      }
    };

    const showRewordError = (bubble) => {
      const wrap = bubble.querySelector('.reword-input-wrap');
      if (wrap) {
        wrap.innerHTML = '<div class="annotation-item" style="color: #c55;">Something went wrong. Try again.</div>';
        setTimeout(() => showRewordInput(bubble), 2000);
      }
    };

    const showRewordPreview = (bubble, original, reworded) => {
      // Remove existing preview/input
      bubble.querySelector('.reword-input-wrap')?.remove();
      bubble.querySelector('.reword-preview')?.remove();

      const preview = document.createElement('div');
      preview.className = 'reword-preview';

      // Show the suggestion
      const suggestion = document.createElement('div');
      suggestion.className = 'reword-suggestion';
      suggestion.textContent = reworded;
      preview.appendChild(suggestion);

      // Action buttons
      const actions = document.createElement('div');
      actions.className = 'reword-preview-actions';

      const acceptBtn = document.createElement('button');
      acceptBtn.className = 'reword-accept';
      acceptBtn.textContent = 'Accept';
      acceptBtn.addEventListener('click', () => {
        acceptReword(reworded);
      });

      const refineBtn = document.createElement('button');
      refineBtn.className = 'reword-refine';
      refineBtn.textContent = 'Refine';
      refineBtn.addEventListener('click', () => {
        preview.remove();
        showRewordInput(bubble, 'Refine further...');
      });

      const cancelBtn = document.createElement('button');
      cancelBtn.className = 'reword-cancel';
      cancelBtn.textContent = 'Cancel';
      cancelBtn.addEventListener('click', () => {
        clearAnnotations();
      });

      actions.appendChild(acceptBtn);
      actions.appendChild(refineBtn);
      actions.appendChild(cancelBtn);
      preview.appendChild(actions);

      // Insert after actions bar
      const actionsBar = bubble.querySelector('.annotation-actions');
      actionsBar.after(preview);
    };

    const acceptReword = (rewordedText) => {
      const context = APP.rewriteContext;
      if (!context) return;

      // Save to history before changing
      saveToHistory(getEditorContent(), 'before-reword');

      // Apply the rewrite
      const sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(context.range);
      document.execCommand('insertText', false, rewordedText);

      // Save after
      const content = getEditorContent();
      updateDocContent(content);
      persistState();
      saveToHistory(content, 'reword');

      clearAnnotations();
      render();
    };

    const generateInsightCompletion = async (insight) => {
      // Get plain text content for LLM
      const editor = $('editor');
      const textContent = getPlainText();

      clearAnnotations();

      // Add a paragraph break and move cursor to end
      const br = document.createElement('br');
      const br2 = document.createElement('br');
      editor.appendChild(br);
      editor.appendChild(br2);

      // Move cursor to end
      const range = document.createRange();
      range.setStartAfter(br2);
      range.collapse(true);
      const sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);

      startSuggestion('complete');
      insertGhost('');
      render();

      try {
        const messages = [
          {
            role: 'system',
            content: `You are a writing assistant. The user has written some text and is exploring a particular angle or question about it. Continue their writing naturally in a way that addresses or weaves in the insight, without explicitly stating the insight. Write as if you are the author continuing their own train of thought. Just continue the text seamlessly - no quotes, no meta-commentary.`,
          },
          {
            role: 'user',
            content: `Here is what I've written:\n\n${textContent}\n\nI want to explore this angle: "${insight}"\n\nContinue my writing naturally:`,
          },
        ];

        for await (const token of llmStream(COMPLETION_MODEL, messages, { temperature: 0.8, max_tokens: 100 })) {
          if (!APP.suggestion || APP.suggestion.mode !== 'complete') break;
          if (token) {
            appendToSuggestion(0, token);
            updateGhost(APP.suggestion.branches[APP.suggestion.selected]);
          }
        }

      } catch (e) {
        console.error('Insight completion error:', e);
      } finally {
        setGenerating(false);
        render();
      }
    };

    const applyRewrite = (newText) => {
      if (!APP.rewriteContext) return;

      // Save to history before changing
      saveToHistory(getEditorContent(), 'before-rewrite');

      // Apply the rewrite
      const sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(APP.rewriteContext.range);

      // Insert new text
      document.execCommand('insertText', false, newText);

      // Save after
      const content = getEditorContent();
      updateDocContent(content);
      persistState();
      saveToHistory(content, 'rewrite');

      clearAnnotations();
      render();
    };

    const handleKeydown = (e) => {
      // Undo
      if (e.key === 'z' && (e.metaKey || e.ctrlKey) && !e.shiftKey) {
        e.preventDefault();
        const content = undo();
        if (content !== null) {
          setEditorContent(content);
          updateDocContent(content);
          persistState();
          clearSuggestion();
          removeGhost();
        }
        render();
        return;
      }

      // Redo
      if ((e.key === 'z' && (e.metaKey || e.ctrlKey) && e.shiftKey) ||
          (e.key === 'y' && (e.metaKey || e.ctrlKey))) {
        e.preventDefault();
        const content = redo();
        if (content !== null) {
          setEditorContent(content);
          updateDocContent(content);
          persistState();
          clearSuggestion();
          removeGhost();
        }
        render();
        return;
      }

      // Branch navigation
      if (e.altKey && (e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
        e.preventDefault();
        const content = switchBranch(e.key === 'ArrowLeft' ? -1 : 1);
        if (content !== null) {
          setEditorContent(content);
          updateDocContent(content);
          persistState();
          clearSuggestion();
          removeGhost();
        }
        render();
        return;
      }

      // Suggestion navigation
      if (APP.suggestion && APP.suggestion.branches.length > 1) {
        if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
          e.preventDefault();
          selectSuggestion(APP.suggestion.selected + (e.key === 'ArrowUp' ? -1 : 1));
          updateGhost(APP.suggestion.branches[APP.suggestion.selected]);
          return;
        }
      }

      // Accept suggestion
      if (e.key === 'Tab' && APP.suggestion) {
        e.preventDefault();
        acceptGhost();
        const content = getEditorContent();
        updateDocContent(content);
        persistState();
        saveToHistory(content, APP.suggestion.mode);
        clearSuggestion();
        render();
        return;
      }

      // Dismiss suggestion
      if (e.key === 'Escape' && APP.suggestion) {
        e.preventDefault();
        if (APP.suggestion.mode === 'rewrite') {
          // Restore original text
          updateGhost(APP.suggestion.original);
          acceptGhost();
        } else {
          removeGhost();
        }
        clearSuggestion();
        render();
        return;
      }
    };

    // ============================================
    // SETTINGS UI
    // ============================================

    const openSettings = () => {
      $('settingsOverlay').classList.add('open');
    };

    const closeSettings = () => {
      $('settingsOverlay').classList.remove('open');
    };

    const clearModelCache = async () => {
      if (!confirm('Clear all downloaded models? They will be re-downloaded when needed.')) return;

      // Clear WebLLM cache
      try {
        const caches = await window.caches.keys();
        for (const cache of caches) {
          if (cache.includes('webllm') || cache.includes('mlc')) {
            await window.caches.delete(cache);
          }
        }
        // Clear engine cache
        Object.keys(engineCache).forEach(k => delete engineCache[k]);
        alert('Model cache cleared. Models will re-download on next use.');
      } catch (e) {
        console.error('Failed to clear cache:', e);
        alert('Failed to clear cache: ' + e.message);
      }
    };

    const clearAllData = () => {
      if (!confirm('Clear ALL data including documents and history? This cannot be undone.')) return;

      localStorage.removeItem('journal-state');
      localStorage.removeItem('journal-settings');
      location.reload();
    };

    // ============================================
    // UNIFIED LLM INTERFACE
    // ============================================

    // Track model loading state for UI feedback
    let modelLoadingStatus = null;

    const getEngine = async (modelSpec) => {
      const [, modelId] = modelSpec.split(':');

      if (!engineCache[modelId]) {
        modelLoadingStatus = { model: modelId, progress: 0 };
        $('loadingText').textContent = `Loading ${modelId}...`;
        engineCache[modelId] = await webllm.CreateMLCEngine(modelId, {
          initProgressCallback: (info) => {
            $('loadingText').textContent = info.text || 'Loading...';
            modelLoadingStatus = { model: modelId, progress: info.progress || 0, text: info.text };
            // Update any visible loading indicators
            document.querySelectorAll('.model-loading-status').forEach(el => {
              el.textContent = info.text || `Loading ${modelId}...`;
            });
          },
        });
        modelLoadingStatus = null;
      }
      return engineCache[modelId];
    };

    const llmComplete = async (modelSpec, messages, options = {}) => {
      const engine = await getEngine(modelSpec);
      const response = await engine.chat.completions.create({
        messages,
        temperature: options.temperature || 0.8,
        max_tokens: options.max_tokens || 40,
      });
      let content = response.choices[0]?.message?.content || '';
      // Filter out DeepSeek thinking tokens
      content = filterThinkingTokens(content);
      return content;
    };

    // Filter out DeepSeek R1 thinking tokens like <think>...</think>
    const filterThinkingTokens = (text) => {
      // Remove <think>...</think> blocks (including partial)
      return text
        .replace(/<think>[\s\S]*?<\/think>/gi, '')
        .replace(/<think>[\s\S]*/gi, '') // Partial opening
        .replace(/[\s\S]*<\/think>/gi, '') // Partial closing
        .trim();
    };

    const llmStream = async function* (modelSpec, messages, options = {}) {
      const engine = await getEngine(modelSpec);
      const stream = await engine.chat.completions.create({
        messages,
        temperature: options.temperature || 0.8,
        max_tokens: options.max_tokens || 40,
        stream: true,
      });

      for await (const chunk of stream) {
        const token = chunk.choices[0]?.delta?.content || '';
        if (token) yield token;
      }
    };

    const loadModels = async () => {
      try {
        // Preload completion model (thinking model loads on demand)
        await getEngine(COMPLETION_MODEL);
      } catch (e) {
        console.error('Failed to load models:', e);
        $('loadingText').textContent = 'Error: ' + e.message;
      }
    };

    // ============================================
    // INIT
    // ============================================

    const init = async () => {
      // Load persisted state
      loadPersistedState();

      // Create first document if none exist
      if (Object.keys(APP.documents).length === 0) {
        addDocument('Untitled');
      }

      // Load current doc content
      const doc = getCurrentDoc(APP);
      if (doc && doc.content) {
        $('editor').innerHTML = doc.content;
      }

      // Setup event listeners
      $('editor').addEventListener('input', handleInput);
      $('editor').addEventListener('keydown', handleKeydown);
      document.addEventListener('selectionchange', handleSelectionChange);
      $('newDocBtn').addEventListener('click', handleNewDocument);

      // Settings event listeners
      $('settingsBtn').addEventListener('click', openSettings);
      $('settingsCancel').addEventListener('click', closeSettings);
      $('clearModelsBtn').addEventListener('click', clearModelCache);
      $('clearStorageBtn').addEventListener('click', clearAllData);
      $('settingsOverlay').addEventListener('click', (e) => {
        if (e.target === $('settingsOverlay')) closeSettings();
      });

      // Initial render (shows doc list while model loads)
      render();

      // Load LLM
      try {
        await loadModels();

        $('loading').classList.add('hidden');
        $('editor').focus();
        render();

        // Start background generation for existing nodes
        queueExistingNodes();

      } catch (e) {
        $('loadingText').textContent = 'Error: ' + e.message;
        console.error(e);
      }
    };

    init();
  </script>
</body>
</html>
